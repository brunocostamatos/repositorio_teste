// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql'
import {
   makePrismaClientClass,
   BaseClientOptions,
   Model
} from 'prisma-client-lib'
import { typeDefs } from './prisma-schema'

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
   U[keyof U]

export type Maybe<T> = T | undefined | null

export interface Exists {
   config: (where?: ConfigWhereInput) => Promise<boolean>
   cron: (where?: CronWhereInput) => Promise<boolean>
   item: (where?: ItemWhereInput) => Promise<boolean>
   source: (where?: SourceWhereInput) => Promise<boolean>
   tag: (where?: TagWhereInput) => Promise<boolean>
   user: (where?: UserWhereInput) => Promise<boolean>
   wave: (where?: WaveWhereInput) => Promise<boolean>
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable

export interface Fragmentable {
   $fragment<T>(fragment: string | DocumentNode): Promise<T>
}

export interface Prisma {
   $exists: Exists
   $graphql: <T = any>(
      query: string,
      variables?: { [key: string]: any }
   ) => Promise<T>

   /**
    * Queries
    */

   config: (where: ConfigWhereUniqueInput) => ConfigNullablePromise
   configs: (args?: {
      where?: ConfigWhereInput
      orderBy?: ConfigOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Config>
   configsConnection: (args?: {
      where?: ConfigWhereInput
      orderBy?: ConfigOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => ConfigConnectionPromise
   cron: (where: CronWhereUniqueInput) => CronNullablePromise
   crons: (args?: {
      where?: CronWhereInput
      orderBy?: CronOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Cron>
   cronsConnection: (args?: {
      where?: CronWhereInput
      orderBy?: CronOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => CronConnectionPromise
   item: (where: ItemWhereUniqueInput) => ItemNullablePromise
   items: (args?: {
      where?: ItemWhereInput
      orderBy?: ItemOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Item>
   itemsConnection: (args?: {
      where?: ItemWhereInput
      orderBy?: ItemOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => ItemConnectionPromise
   source: (where: SourceWhereUniqueInput) => SourceNullablePromise
   sources: (args?: {
      where?: SourceWhereInput
      orderBy?: SourceOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Source>
   sourcesConnection: (args?: {
      where?: SourceWhereInput
      orderBy?: SourceOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => SourceConnectionPromise
   tag: (where: TagWhereUniqueInput) => TagNullablePromise
   tags: (args?: {
      where?: TagWhereInput
      orderBy?: TagOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Tag>
   tagsConnection: (args?: {
      where?: TagWhereInput
      orderBy?: TagOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => TagConnectionPromise
   user: (where: UserWhereUniqueInput) => UserNullablePromise
   users: (args?: {
      where?: UserWhereInput
      orderBy?: UserOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<User>
   usersConnection: (args?: {
      where?: UserWhereInput
      orderBy?: UserOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => UserConnectionPromise
   wave: (where: WaveWhereUniqueInput) => WaveNullablePromise
   waves: (args?: {
      where?: WaveWhereInput
      orderBy?: WaveOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => FragmentableArray<Wave>
   wavesConnection: (args?: {
      where?: WaveWhereInput
      orderBy?: WaveOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => WaveConnectionPromise
   node: (args: { id: ID_Output }) => Node

   /**
    * Mutations
    */

   createConfig: (data: ConfigCreateInput) => ConfigPromise
   updateConfig: (args: {
      data: ConfigUpdateInput
      where: ConfigWhereUniqueInput
   }) => ConfigPromise
   updateManyConfigs: (args: {
      data: ConfigUpdateManyMutationInput
      where?: ConfigWhereInput
   }) => BatchPayloadPromise
   upsertConfig: (args: {
      where: ConfigWhereUniqueInput
      create: ConfigCreateInput
      update: ConfigUpdateInput
   }) => ConfigPromise
   deleteConfig: (where: ConfigWhereUniqueInput) => ConfigPromise
   deleteManyConfigs: (where?: ConfigWhereInput) => BatchPayloadPromise
   createCron: (data: CronCreateInput) => CronPromise
   updateCron: (args: {
      data: CronUpdateInput
      where: CronWhereUniqueInput
   }) => CronPromise
   updateManyCrons: (args: {
      data: CronUpdateManyMutationInput
      where?: CronWhereInput
   }) => BatchPayloadPromise
   upsertCron: (args: {
      where: CronWhereUniqueInput
      create: CronCreateInput
      update: CronUpdateInput
   }) => CronPromise
   deleteCron: (where: CronWhereUniqueInput) => CronPromise
   deleteManyCrons: (where?: CronWhereInput) => BatchPayloadPromise
   createItem: (data: ItemCreateInput) => ItemPromise
   updateItem: (args: {
      data: ItemUpdateInput
      where: ItemWhereUniqueInput
   }) => ItemPromise
   updateManyItems: (args: {
      data: ItemUpdateManyMutationInput
      where?: ItemWhereInput
   }) => BatchPayloadPromise
   upsertItem: (args: {
      where: ItemWhereUniqueInput
      create: ItemCreateInput
      update: ItemUpdateInput
   }) => ItemPromise
   deleteItem: (where: ItemWhereUniqueInput) => ItemPromise
   deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise
   createSource: (data: SourceCreateInput) => SourcePromise
   updateSource: (args: {
      data: SourceUpdateInput
      where: SourceWhereUniqueInput
   }) => SourcePromise
   updateManySources: (args: {
      data: SourceUpdateManyMutationInput
      where?: SourceWhereInput
   }) => BatchPayloadPromise
   upsertSource: (args: {
      where: SourceWhereUniqueInput
      create: SourceCreateInput
      update: SourceUpdateInput
   }) => SourcePromise
   deleteSource: (where: SourceWhereUniqueInput) => SourcePromise
   deleteManySources: (where?: SourceWhereInput) => BatchPayloadPromise
   createTag: (data: TagCreateInput) => TagPromise
   updateTag: (args: {
      data: TagUpdateInput
      where: TagWhereUniqueInput
   }) => TagPromise
   updateManyTags: (args: {
      data: TagUpdateManyMutationInput
      where?: TagWhereInput
   }) => BatchPayloadPromise
   upsertTag: (args: {
      where: TagWhereUniqueInput
      create: TagCreateInput
      update: TagUpdateInput
   }) => TagPromise
   deleteTag: (where: TagWhereUniqueInput) => TagPromise
   deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise
   createUser: (data: UserCreateInput) => UserPromise
   updateUser: (args: {
      data: UserUpdateInput
      where: UserWhereUniqueInput
   }) => UserPromise
   updateManyUsers: (args: {
      data: UserUpdateManyMutationInput
      where?: UserWhereInput
   }) => BatchPayloadPromise
   upsertUser: (args: {
      where: UserWhereUniqueInput
      create: UserCreateInput
      update: UserUpdateInput
   }) => UserPromise
   deleteUser: (where: UserWhereUniqueInput) => UserPromise
   deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise
   createWave: (data: WaveCreateInput) => WavePromise
   updateWave: (args: {
      data: WaveUpdateInput
      where: WaveWhereUniqueInput
   }) => WavePromise
   updateManyWaves: (args: {
      data: WaveUpdateManyMutationInput
      where?: WaveWhereInput
   }) => BatchPayloadPromise
   upsertWave: (args: {
      where: WaveWhereUniqueInput
      create: WaveCreateInput
      update: WaveUpdateInput
   }) => WavePromise
   deleteWave: (where: WaveWhereUniqueInput) => WavePromise
   deleteManyWaves: (where?: WaveWhereInput) => BatchPayloadPromise

   /**
    * Subscriptions
    */

   $subscribe: Subscription
}

export interface Subscription {
   config: (
      where?: ConfigSubscriptionWhereInput
   ) => ConfigSubscriptionPayloadSubscription
   cron: (
      where?: CronSubscriptionWhereInput
   ) => CronSubscriptionPayloadSubscription
   item: (
      where?: ItemSubscriptionWhereInput
   ) => ItemSubscriptionPayloadSubscription
   source: (
      where?: SourceSubscriptionWhereInput
   ) => SourceSubscriptionPayloadSubscription
   tag: (
      where?: TagSubscriptionWhereInput
   ) => TagSubscriptionPayloadSubscription
   user: (
      where?: UserSubscriptionWhereInput
   ) => UserSubscriptionPayloadSubscription
   wave: (
      where?: WaveSubscriptionWhereInput
   ) => WaveSubscriptionPayloadSubscription
}

export interface ClientConstructor<T> {
   new (options?: BaseClientOptions): T
}

/**
 * Types
 */

export type ConfigOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'createdAt_ASC'
   | 'createdAt_DESC'
   | 'updatedAt_ASC'
   | 'updatedAt_DESC'
   | 'timeZone_ASC'
   | 'timeZone_DESC'
   | 'liveUrl_ASC'
   | 'liveUrl_DESC'
   | 'liveStatusUrl_ASC'
   | 'liveStatusUrl_DESC'
   | 'placeholderCover_ASC'
   | 'placeholderCover_DESC'

export type CronEnum = 'STARTING' | 'RUNNING' | 'IDLE' | 'STOPED'

export type CronOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'createdAt_ASC'
   | 'createdAt_DESC'
   | 'updatedAt_ASC'
   | 'updatedAt_DESC'
   | 'pid_ASC'
   | 'pid_DESC'
   | 'health_ASC'
   | 'health_DESC'
   | 'status_ASC'
   | 'status_DESC'
   | 'lastMessage_ASC'
   | 'lastMessage_DESC'

export type TagOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'createdAt_ASC'
   | 'createdAt_DESC'
   | 'updatedAt_ASC'
   | 'updatedAt_DESC'
   | 'tag_ASC'
   | 'tag_DESC'
   | 'name_ASC'
   | 'name_DESC'
   | 'text_ASC'
   | 'text_DESC'

export type SourceEnum = 'PODCAST' | 'NEWS' | 'PAGE'

export type ItemOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'createdAt_ASC'
   | 'createdAt_DESC'
   | 'updatedAt_ASC'
   | 'updatedAt_DESC'
   | 'slug_ASC'
   | 'slug_DESC'
   | 'guid_ASC'
   | 'guid_DESC'
   | 'title_ASC'
   | 'title_DESC'
   | 'description_ASC'
   | 'description_DESC'
   | 'publishedAt_ASC'
   | 'publishedAt_DESC'
   | 'download_ASC'
   | 'download_DESC'
   | 'url_ASC'
   | 'url_DESC'
   | 'length_ASC'
   | 'length_DESC'
   | 'type_ASC'
   | 'type_DESC'

export type SourceOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'createdAt_ASC'
   | 'createdAt_DESC'
   | 'updatedAt_ASC'
   | 'updatedAt_DESC'
   | 'slug_ASC'
   | 'slug_DESC'
   | 'url_ASC'
   | 'url_DESC'
   | 'type_ASC'
   | 'type_DESC'
   | 'title_ASC'
   | 'title_DESC'
   | 'description_ASC'
   | 'description_DESC'
   | 'timer_ASC'
   | 'timer_DESC'
   | 'cover_ASC'
   | 'cover_DESC'

export type UserOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'createdAt_ASC'
   | 'createdAt_DESC'
   | 'updatedAt_ASC'
   | 'updatedAt_DESC'
   | 'name_ASC'
   | 'name_DESC'
   | 'bio_ASC'
   | 'bio_DESC'
   | 'userName_ASC'
   | 'userName_DESC'
   | 'email_ASC'
   | 'email_DESC'
   | 'password_ASC'
   | 'password_DESC'

export type WaveOrderByInput =
   | 'id_ASC'
   | 'id_DESC'
   | 'createdAt_ASC'
   | 'createdAt_DESC'
   | 'updatedAt_ASC'
   | 'updatedAt_DESC'
   | 'url_ASC'
   | 'url_DESC'

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED'

export type ConfigWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
}>

export interface ConfigWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   createdAt?: Maybe<DateTimeInput>
   createdAt_not?: Maybe<DateTimeInput>
   createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_lt?: Maybe<DateTimeInput>
   createdAt_lte?: Maybe<DateTimeInput>
   createdAt_gt?: Maybe<DateTimeInput>
   createdAt_gte?: Maybe<DateTimeInput>
   updatedAt?: Maybe<DateTimeInput>
   updatedAt_not?: Maybe<DateTimeInput>
   updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_lt?: Maybe<DateTimeInput>
   updatedAt_lte?: Maybe<DateTimeInput>
   updatedAt_gt?: Maybe<DateTimeInput>
   updatedAt_gte?: Maybe<DateTimeInput>
   timeZone?: Maybe<String>
   timeZone_not?: Maybe<String>
   timeZone_in?: Maybe<String[] | String>
   timeZone_not_in?: Maybe<String[] | String>
   timeZone_lt?: Maybe<String>
   timeZone_lte?: Maybe<String>
   timeZone_gt?: Maybe<String>
   timeZone_gte?: Maybe<String>
   timeZone_contains?: Maybe<String>
   timeZone_not_contains?: Maybe<String>
   timeZone_starts_with?: Maybe<String>
   timeZone_not_starts_with?: Maybe<String>
   timeZone_ends_with?: Maybe<String>
   timeZone_not_ends_with?: Maybe<String>
   liveUrl?: Maybe<String>
   liveUrl_not?: Maybe<String>
   liveUrl_in?: Maybe<String[] | String>
   liveUrl_not_in?: Maybe<String[] | String>
   liveUrl_lt?: Maybe<String>
   liveUrl_lte?: Maybe<String>
   liveUrl_gt?: Maybe<String>
   liveUrl_gte?: Maybe<String>
   liveUrl_contains?: Maybe<String>
   liveUrl_not_contains?: Maybe<String>
   liveUrl_starts_with?: Maybe<String>
   liveUrl_not_starts_with?: Maybe<String>
   liveUrl_ends_with?: Maybe<String>
   liveUrl_not_ends_with?: Maybe<String>
   liveStatusUrl?: Maybe<String>
   liveStatusUrl_not?: Maybe<String>
   liveStatusUrl_in?: Maybe<String[] | String>
   liveStatusUrl_not_in?: Maybe<String[] | String>
   liveStatusUrl_lt?: Maybe<String>
   liveStatusUrl_lte?: Maybe<String>
   liveStatusUrl_gt?: Maybe<String>
   liveStatusUrl_gte?: Maybe<String>
   liveStatusUrl_contains?: Maybe<String>
   liveStatusUrl_not_contains?: Maybe<String>
   liveStatusUrl_starts_with?: Maybe<String>
   liveStatusUrl_not_starts_with?: Maybe<String>
   liveStatusUrl_ends_with?: Maybe<String>
   liveStatusUrl_not_ends_with?: Maybe<String>
   placeholderCover?: Maybe<String>
   placeholderCover_not?: Maybe<String>
   placeholderCover_in?: Maybe<String[] | String>
   placeholderCover_not_in?: Maybe<String[] | String>
   placeholderCover_lt?: Maybe<String>
   placeholderCover_lte?: Maybe<String>
   placeholderCover_gt?: Maybe<String>
   placeholderCover_gte?: Maybe<String>
   placeholderCover_contains?: Maybe<String>
   placeholderCover_not_contains?: Maybe<String>
   placeholderCover_starts_with?: Maybe<String>
   placeholderCover_not_starts_with?: Maybe<String>
   placeholderCover_ends_with?: Maybe<String>
   placeholderCover_not_ends_with?: Maybe<String>
   AND?: Maybe<ConfigWhereInput[] | ConfigWhereInput>
}

export type CronWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
   pid?: Maybe<Int>
}>

export interface CronWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   createdAt?: Maybe<DateTimeInput>
   createdAt_not?: Maybe<DateTimeInput>
   createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_lt?: Maybe<DateTimeInput>
   createdAt_lte?: Maybe<DateTimeInput>
   createdAt_gt?: Maybe<DateTimeInput>
   createdAt_gte?: Maybe<DateTimeInput>
   updatedAt?: Maybe<DateTimeInput>
   updatedAt_not?: Maybe<DateTimeInput>
   updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_lt?: Maybe<DateTimeInput>
   updatedAt_lte?: Maybe<DateTimeInput>
   updatedAt_gt?: Maybe<DateTimeInput>
   updatedAt_gte?: Maybe<DateTimeInput>
   pid?: Maybe<Int>
   pid_not?: Maybe<Int>
   pid_in?: Maybe<Int[] | Int>
   pid_not_in?: Maybe<Int[] | Int>
   pid_lt?: Maybe<Int>
   pid_lte?: Maybe<Int>
   pid_gt?: Maybe<Int>
   pid_gte?: Maybe<Int>
   health?: Maybe<Boolean>
   health_not?: Maybe<Boolean>
   status?: Maybe<CronEnum>
   status_not?: Maybe<CronEnum>
   status_in?: Maybe<CronEnum[] | CronEnum>
   status_not_in?: Maybe<CronEnum[] | CronEnum>
   lastMessage?: Maybe<String>
   lastMessage_not?: Maybe<String>
   lastMessage_in?: Maybe<String[] | String>
   lastMessage_not_in?: Maybe<String[] | String>
   lastMessage_lt?: Maybe<String>
   lastMessage_lte?: Maybe<String>
   lastMessage_gt?: Maybe<String>
   lastMessage_gte?: Maybe<String>
   lastMessage_contains?: Maybe<String>
   lastMessage_not_contains?: Maybe<String>
   lastMessage_starts_with?: Maybe<String>
   lastMessage_not_starts_with?: Maybe<String>
   lastMessage_ends_with?: Maybe<String>
   lastMessage_not_ends_with?: Maybe<String>
   AND?: Maybe<CronWhereInput[] | CronWhereInput>
}

export type ItemWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
   slug?: Maybe<String>
   guid?: Maybe<String>
}>

export interface TagWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   createdAt?: Maybe<DateTimeInput>
   createdAt_not?: Maybe<DateTimeInput>
   createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_lt?: Maybe<DateTimeInput>
   createdAt_lte?: Maybe<DateTimeInput>
   createdAt_gt?: Maybe<DateTimeInput>
   createdAt_gte?: Maybe<DateTimeInput>
   updatedAt?: Maybe<DateTimeInput>
   updatedAt_not?: Maybe<DateTimeInput>
   updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_lt?: Maybe<DateTimeInput>
   updatedAt_lte?: Maybe<DateTimeInput>
   updatedAt_gt?: Maybe<DateTimeInput>
   updatedAt_gte?: Maybe<DateTimeInput>
   tag?: Maybe<Int>
   tag_not?: Maybe<Int>
   tag_in?: Maybe<Int[] | Int>
   tag_not_in?: Maybe<Int[] | Int>
   tag_lt?: Maybe<Int>
   tag_lte?: Maybe<Int>
   tag_gt?: Maybe<Int>
   tag_gte?: Maybe<Int>
   name?: Maybe<String>
   name_not?: Maybe<String>
   name_in?: Maybe<String[] | String>
   name_not_in?: Maybe<String[] | String>
   name_lt?: Maybe<String>
   name_lte?: Maybe<String>
   name_gt?: Maybe<String>
   name_gte?: Maybe<String>
   name_contains?: Maybe<String>
   name_not_contains?: Maybe<String>
   name_starts_with?: Maybe<String>
   name_not_starts_with?: Maybe<String>
   name_ends_with?: Maybe<String>
   name_not_ends_with?: Maybe<String>
   text?: Maybe<String>
   text_not?: Maybe<String>
   text_in?: Maybe<String[] | String>
   text_not_in?: Maybe<String[] | String>
   text_lt?: Maybe<String>
   text_lte?: Maybe<String>
   text_gt?: Maybe<String>
   text_gte?: Maybe<String>
   text_contains?: Maybe<String>
   text_not_contains?: Maybe<String>
   text_starts_with?: Maybe<String>
   text_not_starts_with?: Maybe<String>
   text_ends_with?: Maybe<String>
   text_not_ends_with?: Maybe<String>
   AND?: Maybe<TagWhereInput[] | TagWhereInput>
}

export interface ItemWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   createdAt?: Maybe<DateTimeInput>
   createdAt_not?: Maybe<DateTimeInput>
   createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_lt?: Maybe<DateTimeInput>
   createdAt_lte?: Maybe<DateTimeInput>
   createdAt_gt?: Maybe<DateTimeInput>
   createdAt_gte?: Maybe<DateTimeInput>
   updatedAt?: Maybe<DateTimeInput>
   updatedAt_not?: Maybe<DateTimeInput>
   updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_lt?: Maybe<DateTimeInput>
   updatedAt_lte?: Maybe<DateTimeInput>
   updatedAt_gt?: Maybe<DateTimeInput>
   updatedAt_gte?: Maybe<DateTimeInput>
   slug?: Maybe<String>
   slug_not?: Maybe<String>
   slug_in?: Maybe<String[] | String>
   slug_not_in?: Maybe<String[] | String>
   slug_lt?: Maybe<String>
   slug_lte?: Maybe<String>
   slug_gt?: Maybe<String>
   slug_gte?: Maybe<String>
   slug_contains?: Maybe<String>
   slug_not_contains?: Maybe<String>
   slug_starts_with?: Maybe<String>
   slug_not_starts_with?: Maybe<String>
   slug_ends_with?: Maybe<String>
   slug_not_ends_with?: Maybe<String>
   guid?: Maybe<String>
   guid_not?: Maybe<String>
   guid_in?: Maybe<String[] | String>
   guid_not_in?: Maybe<String[] | String>
   guid_lt?: Maybe<String>
   guid_lte?: Maybe<String>
   guid_gt?: Maybe<String>
   guid_gte?: Maybe<String>
   guid_contains?: Maybe<String>
   guid_not_contains?: Maybe<String>
   guid_starts_with?: Maybe<String>
   guid_not_starts_with?: Maybe<String>
   guid_ends_with?: Maybe<String>
   guid_not_ends_with?: Maybe<String>
   tags_some?: Maybe<TagWhereInput>
   title?: Maybe<String>
   title_not?: Maybe<String>
   title_in?: Maybe<String[] | String>
   title_not_in?: Maybe<String[] | String>
   title_lt?: Maybe<String>
   title_lte?: Maybe<String>
   title_gt?: Maybe<String>
   title_gte?: Maybe<String>
   title_contains?: Maybe<String>
   title_not_contains?: Maybe<String>
   title_starts_with?: Maybe<String>
   title_not_starts_with?: Maybe<String>
   title_ends_with?: Maybe<String>
   title_not_ends_with?: Maybe<String>
   description?: Maybe<String>
   description_not?: Maybe<String>
   description_in?: Maybe<String[] | String>
   description_not_in?: Maybe<String[] | String>
   description_lt?: Maybe<String>
   description_lte?: Maybe<String>
   description_gt?: Maybe<String>
   description_gte?: Maybe<String>
   description_contains?: Maybe<String>
   description_not_contains?: Maybe<String>
   description_starts_with?: Maybe<String>
   description_not_starts_with?: Maybe<String>
   description_ends_with?: Maybe<String>
   description_not_ends_with?: Maybe<String>
   publishedAt?: Maybe<DateTimeInput>
   publishedAt_not?: Maybe<DateTimeInput>
   publishedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   publishedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   publishedAt_lt?: Maybe<DateTimeInput>
   publishedAt_lte?: Maybe<DateTimeInput>
   publishedAt_gt?: Maybe<DateTimeInput>
   publishedAt_gte?: Maybe<DateTimeInput>
   download?: Maybe<String>
   download_not?: Maybe<String>
   download_in?: Maybe<String[] | String>
   download_not_in?: Maybe<String[] | String>
   download_lt?: Maybe<String>
   download_lte?: Maybe<String>
   download_gt?: Maybe<String>
   download_gte?: Maybe<String>
   download_contains?: Maybe<String>
   download_not_contains?: Maybe<String>
   download_starts_with?: Maybe<String>
   download_not_starts_with?: Maybe<String>
   download_ends_with?: Maybe<String>
   download_not_ends_with?: Maybe<String>
   url?: Maybe<String>
   url_not?: Maybe<String>
   url_in?: Maybe<String[] | String>
   url_not_in?: Maybe<String[] | String>
   url_lt?: Maybe<String>
   url_lte?: Maybe<String>
   url_gt?: Maybe<String>
   url_gte?: Maybe<String>
   url_contains?: Maybe<String>
   url_not_contains?: Maybe<String>
   url_starts_with?: Maybe<String>
   url_not_starts_with?: Maybe<String>
   url_ends_with?: Maybe<String>
   url_not_ends_with?: Maybe<String>
   length?: Maybe<Int>
   length_not?: Maybe<Int>
   length_in?: Maybe<Int[] | Int>
   length_not_in?: Maybe<Int[] | Int>
   length_lt?: Maybe<Int>
   length_lte?: Maybe<Int>
   length_gt?: Maybe<Int>
   length_gte?: Maybe<Int>
   type?: Maybe<String>
   type_not?: Maybe<String>
   type_in?: Maybe<String[] | String>
   type_not_in?: Maybe<String[] | String>
   type_lt?: Maybe<String>
   type_lte?: Maybe<String>
   type_gt?: Maybe<String>
   type_gte?: Maybe<String>
   type_contains?: Maybe<String>
   type_not_contains?: Maybe<String>
   type_starts_with?: Maybe<String>
   type_not_starts_with?: Maybe<String>
   type_ends_with?: Maybe<String>
   type_not_ends_with?: Maybe<String>
   source?: Maybe<SourceWhereInput>
   waveform?: Maybe<WaveWhereInput>
   AND?: Maybe<ItemWhereInput[] | ItemWhereInput>
}

export interface SourceWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   createdAt?: Maybe<DateTimeInput>
   createdAt_not?: Maybe<DateTimeInput>
   createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_lt?: Maybe<DateTimeInput>
   createdAt_lte?: Maybe<DateTimeInput>
   createdAt_gt?: Maybe<DateTimeInput>
   createdAt_gte?: Maybe<DateTimeInput>
   updatedAt?: Maybe<DateTimeInput>
   updatedAt_not?: Maybe<DateTimeInput>
   updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_lt?: Maybe<DateTimeInput>
   updatedAt_lte?: Maybe<DateTimeInput>
   updatedAt_gt?: Maybe<DateTimeInput>
   updatedAt_gte?: Maybe<DateTimeInput>
   slug?: Maybe<String>
   slug_not?: Maybe<String>
   slug_in?: Maybe<String[] | String>
   slug_not_in?: Maybe<String[] | String>
   slug_lt?: Maybe<String>
   slug_lte?: Maybe<String>
   slug_gt?: Maybe<String>
   slug_gte?: Maybe<String>
   slug_contains?: Maybe<String>
   slug_not_contains?: Maybe<String>
   slug_starts_with?: Maybe<String>
   slug_not_starts_with?: Maybe<String>
   slug_ends_with?: Maybe<String>
   slug_not_ends_with?: Maybe<String>
   url?: Maybe<String>
   url_not?: Maybe<String>
   url_in?: Maybe<String[] | String>
   url_not_in?: Maybe<String[] | String>
   url_lt?: Maybe<String>
   url_lte?: Maybe<String>
   url_gt?: Maybe<String>
   url_gte?: Maybe<String>
   url_contains?: Maybe<String>
   url_not_contains?: Maybe<String>
   url_starts_with?: Maybe<String>
   url_not_starts_with?: Maybe<String>
   url_ends_with?: Maybe<String>
   url_not_ends_with?: Maybe<String>
   type?: Maybe<SourceEnum>
   type_not?: Maybe<SourceEnum>
   type_in?: Maybe<SourceEnum[] | SourceEnum>
   type_not_in?: Maybe<SourceEnum[] | SourceEnum>
   title?: Maybe<String>
   title_not?: Maybe<String>
   title_in?: Maybe<String[] | String>
   title_not_in?: Maybe<String[] | String>
   title_lt?: Maybe<String>
   title_lte?: Maybe<String>
   title_gt?: Maybe<String>
   title_gte?: Maybe<String>
   title_contains?: Maybe<String>
   title_not_contains?: Maybe<String>
   title_starts_with?: Maybe<String>
   title_not_starts_with?: Maybe<String>
   title_ends_with?: Maybe<String>
   title_not_ends_with?: Maybe<String>
   description?: Maybe<String>
   description_not?: Maybe<String>
   description_in?: Maybe<String[] | String>
   description_not_in?: Maybe<String[] | String>
   description_lt?: Maybe<String>
   description_lte?: Maybe<String>
   description_gt?: Maybe<String>
   description_gte?: Maybe<String>
   description_contains?: Maybe<String>
   description_not_contains?: Maybe<String>
   description_starts_with?: Maybe<String>
   description_not_starts_with?: Maybe<String>
   description_ends_with?: Maybe<String>
   description_not_ends_with?: Maybe<String>
   items_some?: Maybe<ItemWhereInput>
   timer?: Maybe<String>
   timer_not?: Maybe<String>
   timer_in?: Maybe<String[] | String>
   timer_not_in?: Maybe<String[] | String>
   timer_lt?: Maybe<String>
   timer_lte?: Maybe<String>
   timer_gt?: Maybe<String>
   timer_gte?: Maybe<String>
   timer_contains?: Maybe<String>
   timer_not_contains?: Maybe<String>
   timer_starts_with?: Maybe<String>
   timer_not_starts_with?: Maybe<String>
   timer_ends_with?: Maybe<String>
   timer_not_ends_with?: Maybe<String>
   cron?: Maybe<CronWhereInput>
   cover?: Maybe<String>
   cover_not?: Maybe<String>
   cover_in?: Maybe<String[] | String>
   cover_not_in?: Maybe<String[] | String>
   cover_lt?: Maybe<String>
   cover_lte?: Maybe<String>
   cover_gt?: Maybe<String>
   cover_gte?: Maybe<String>
   cover_contains?: Maybe<String>
   cover_not_contains?: Maybe<String>
   cover_starts_with?: Maybe<String>
   cover_not_starts_with?: Maybe<String>
   cover_ends_with?: Maybe<String>
   cover_not_ends_with?: Maybe<String>
   AND?: Maybe<SourceWhereInput[] | SourceWhereInput>
}

export interface WaveWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   createdAt?: Maybe<DateTimeInput>
   createdAt_not?: Maybe<DateTimeInput>
   createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_lt?: Maybe<DateTimeInput>
   createdAt_lte?: Maybe<DateTimeInput>
   createdAt_gt?: Maybe<DateTimeInput>
   createdAt_gte?: Maybe<DateTimeInput>
   updatedAt?: Maybe<DateTimeInput>
   updatedAt_not?: Maybe<DateTimeInput>
   updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_lt?: Maybe<DateTimeInput>
   updatedAt_lte?: Maybe<DateTimeInput>
   updatedAt_gt?: Maybe<DateTimeInput>
   updatedAt_gte?: Maybe<DateTimeInput>
   url?: Maybe<String>
   url_not?: Maybe<String>
   url_in?: Maybe<String[] | String>
   url_not_in?: Maybe<String[] | String>
   url_lt?: Maybe<String>
   url_lte?: Maybe<String>
   url_gt?: Maybe<String>
   url_gte?: Maybe<String>
   url_contains?: Maybe<String>
   url_not_contains?: Maybe<String>
   url_starts_with?: Maybe<String>
   url_not_starts_with?: Maybe<String>
   url_ends_with?: Maybe<String>
   url_not_ends_with?: Maybe<String>
   AND?: Maybe<WaveWhereInput[] | WaveWhereInput>
}

export type SourceWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
   slug?: Maybe<String>
   url?: Maybe<String>
}>

export type TagWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
   tag?: Maybe<Int>
}>

export type UserWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
   userName?: Maybe<String>
   email?: Maybe<String>
}>

export interface UserWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   createdAt?: Maybe<DateTimeInput>
   createdAt_not?: Maybe<DateTimeInput>
   createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_lt?: Maybe<DateTimeInput>
   createdAt_lte?: Maybe<DateTimeInput>
   createdAt_gt?: Maybe<DateTimeInput>
   createdAt_gte?: Maybe<DateTimeInput>
   updatedAt?: Maybe<DateTimeInput>
   updatedAt_not?: Maybe<DateTimeInput>
   updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_lt?: Maybe<DateTimeInput>
   updatedAt_lte?: Maybe<DateTimeInput>
   updatedAt_gt?: Maybe<DateTimeInput>
   updatedAt_gte?: Maybe<DateTimeInput>
   name?: Maybe<String>
   name_not?: Maybe<String>
   name_in?: Maybe<String[] | String>
   name_not_in?: Maybe<String[] | String>
   name_lt?: Maybe<String>
   name_lte?: Maybe<String>
   name_gt?: Maybe<String>
   name_gte?: Maybe<String>
   name_contains?: Maybe<String>
   name_not_contains?: Maybe<String>
   name_starts_with?: Maybe<String>
   name_not_starts_with?: Maybe<String>
   name_ends_with?: Maybe<String>
   name_not_ends_with?: Maybe<String>
   bio?: Maybe<String>
   bio_not?: Maybe<String>
   bio_in?: Maybe<String[] | String>
   bio_not_in?: Maybe<String[] | String>
   bio_lt?: Maybe<String>
   bio_lte?: Maybe<String>
   bio_gt?: Maybe<String>
   bio_gte?: Maybe<String>
   bio_contains?: Maybe<String>
   bio_not_contains?: Maybe<String>
   bio_starts_with?: Maybe<String>
   bio_not_starts_with?: Maybe<String>
   bio_ends_with?: Maybe<String>
   bio_not_ends_with?: Maybe<String>
   userName?: Maybe<String>
   userName_not?: Maybe<String>
   userName_in?: Maybe<String[] | String>
   userName_not_in?: Maybe<String[] | String>
   userName_lt?: Maybe<String>
   userName_lte?: Maybe<String>
   userName_gt?: Maybe<String>
   userName_gte?: Maybe<String>
   userName_contains?: Maybe<String>
   userName_not_contains?: Maybe<String>
   userName_starts_with?: Maybe<String>
   userName_not_starts_with?: Maybe<String>
   userName_ends_with?: Maybe<String>
   userName_not_ends_with?: Maybe<String>
   email?: Maybe<String>
   email_not?: Maybe<String>
   email_in?: Maybe<String[] | String>
   email_not_in?: Maybe<String[] | String>
   email_lt?: Maybe<String>
   email_lte?: Maybe<String>
   email_gt?: Maybe<String>
   email_gte?: Maybe<String>
   email_contains?: Maybe<String>
   email_not_contains?: Maybe<String>
   email_starts_with?: Maybe<String>
   email_not_starts_with?: Maybe<String>
   email_ends_with?: Maybe<String>
   email_not_ends_with?: Maybe<String>
   password?: Maybe<String>
   password_not?: Maybe<String>
   password_in?: Maybe<String[] | String>
   password_not_in?: Maybe<String[] | String>
   password_lt?: Maybe<String>
   password_lte?: Maybe<String>
   password_gt?: Maybe<String>
   password_gte?: Maybe<String>
   password_contains?: Maybe<String>
   password_not_contains?: Maybe<String>
   password_starts_with?: Maybe<String>
   password_not_starts_with?: Maybe<String>
   password_ends_with?: Maybe<String>
   password_not_ends_with?: Maybe<String>
   AND?: Maybe<UserWhereInput[] | UserWhereInput>
}

export type WaveWhereUniqueInput = AtLeastOne<{
   id: Maybe<ID_Input>
   url?: Maybe<String>
}>

export interface ConfigCreateInput {
   id?: Maybe<ID_Input>
   timeZone: String
   liveUrl: String
   liveStatusUrl: String
   placeholderCover: String
}

export interface ConfigUpdateInput {
   timeZone?: Maybe<String>
   liveUrl?: Maybe<String>
   liveStatusUrl?: Maybe<String>
   placeholderCover?: Maybe<String>
}

export interface ConfigUpdateManyMutationInput {
   timeZone?: Maybe<String>
   liveUrl?: Maybe<String>
   liveStatusUrl?: Maybe<String>
   placeholderCover?: Maybe<String>
}

export interface CronCreateInput {
   id?: Maybe<ID_Input>
   pid: Int
   health?: Maybe<Boolean>
   status: CronEnum
   lastMessage?: Maybe<String>
}

export interface CronUpdateInput {
   pid?: Maybe<Int>
   health?: Maybe<Boolean>
   status?: Maybe<CronEnum>
   lastMessage?: Maybe<String>
}

export interface CronUpdateManyMutationInput {
   pid?: Maybe<Int>
   health?: Maybe<Boolean>
   status?: Maybe<CronEnum>
   lastMessage?: Maybe<String>
}

export interface ItemCreateInput {
   id?: Maybe<ID_Input>
   slug: String
   guid: String
   tags?: Maybe<TagCreateManyInput>
   title?: Maybe<String>
   description?: Maybe<String>
   publishedAt?: Maybe<DateTimeInput>
   download?: Maybe<String>
   url?: Maybe<String>
   length?: Maybe<Int>
   type?: Maybe<String>
   source?: Maybe<SourceCreateOneWithoutItemsInput>
   waveform?: Maybe<WaveCreateOneInput>
}

export interface TagCreateManyInput {
   create?: Maybe<TagCreateInput[] | TagCreateInput>
   connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>
}

export interface TagCreateInput {
   id?: Maybe<ID_Input>
   tag: Int
   name: String
   text: String
}

export interface SourceCreateOneWithoutItemsInput {
   create?: Maybe<SourceCreateWithoutItemsInput>
   connect?: Maybe<SourceWhereUniqueInput>
}

export interface SourceCreateWithoutItemsInput {
   id?: Maybe<ID_Input>
   slug?: Maybe<String>
   url: String
   type?: Maybe<SourceEnum>
   title?: Maybe<String>
   description?: Maybe<String>
   timer?: Maybe<String>
   cron?: Maybe<CronCreateOneInput>
   cover?: Maybe<String>
}

export interface CronCreateOneInput {
   create?: Maybe<CronCreateInput>
   connect?: Maybe<CronWhereUniqueInput>
}

export interface WaveCreateOneInput {
   create?: Maybe<WaveCreateInput>
   connect?: Maybe<WaveWhereUniqueInput>
}

export interface WaveCreateInput {
   id?: Maybe<ID_Input>
   url: String
   wave?: Maybe<WaveCreatewaveInput>
}

export interface WaveCreatewaveInput {
   set?: Maybe<Float[] | Float>
}

export interface ItemUpdateInput {
   slug?: Maybe<String>
   guid?: Maybe<String>
   tags?: Maybe<TagUpdateManyInput>
   title?: Maybe<String>
   description?: Maybe<String>
   publishedAt?: Maybe<DateTimeInput>
   download?: Maybe<String>
   url?: Maybe<String>
   length?: Maybe<Int>
   type?: Maybe<String>
   source?: Maybe<SourceUpdateOneWithoutItemsInput>
   waveform?: Maybe<WaveUpdateOneInput>
}

export interface TagUpdateManyInput {
   create?: Maybe<TagCreateInput[] | TagCreateInput>
   update?: Maybe<
      | TagUpdateWithWhereUniqueNestedInput[]
      | TagUpdateWithWhereUniqueNestedInput
   >
   upsert?: Maybe<
      | TagUpsertWithWhereUniqueNestedInput[]
      | TagUpsertWithWhereUniqueNestedInput
   >
   delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>
   connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>
   set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>
   disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>
   deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>
   updateMany?: Maybe<
      TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
   >
}

export interface TagUpdateWithWhereUniqueNestedInput {
   where: TagWhereUniqueInput
   data: TagUpdateDataInput
}

export interface TagUpdateDataInput {
   tag?: Maybe<Int>
   name?: Maybe<String>
   text?: Maybe<String>
}

export interface TagUpsertWithWhereUniqueNestedInput {
   where: TagWhereUniqueInput
   update: TagUpdateDataInput
   create: TagCreateInput
}

export interface TagScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   createdAt?: Maybe<DateTimeInput>
   createdAt_not?: Maybe<DateTimeInput>
   createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_lt?: Maybe<DateTimeInput>
   createdAt_lte?: Maybe<DateTimeInput>
   createdAt_gt?: Maybe<DateTimeInput>
   createdAt_gte?: Maybe<DateTimeInput>
   updatedAt?: Maybe<DateTimeInput>
   updatedAt_not?: Maybe<DateTimeInput>
   updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_lt?: Maybe<DateTimeInput>
   updatedAt_lte?: Maybe<DateTimeInput>
   updatedAt_gt?: Maybe<DateTimeInput>
   updatedAt_gte?: Maybe<DateTimeInput>
   tag?: Maybe<Int>
   tag_not?: Maybe<Int>
   tag_in?: Maybe<Int[] | Int>
   tag_not_in?: Maybe<Int[] | Int>
   tag_lt?: Maybe<Int>
   tag_lte?: Maybe<Int>
   tag_gt?: Maybe<Int>
   tag_gte?: Maybe<Int>
   name?: Maybe<String>
   name_not?: Maybe<String>
   name_in?: Maybe<String[] | String>
   name_not_in?: Maybe<String[] | String>
   name_lt?: Maybe<String>
   name_lte?: Maybe<String>
   name_gt?: Maybe<String>
   name_gte?: Maybe<String>
   name_contains?: Maybe<String>
   name_not_contains?: Maybe<String>
   name_starts_with?: Maybe<String>
   name_not_starts_with?: Maybe<String>
   name_ends_with?: Maybe<String>
   name_not_ends_with?: Maybe<String>
   text?: Maybe<String>
   text_not?: Maybe<String>
   text_in?: Maybe<String[] | String>
   text_not_in?: Maybe<String[] | String>
   text_lt?: Maybe<String>
   text_lte?: Maybe<String>
   text_gt?: Maybe<String>
   text_gte?: Maybe<String>
   text_contains?: Maybe<String>
   text_not_contains?: Maybe<String>
   text_starts_with?: Maybe<String>
   text_not_starts_with?: Maybe<String>
   text_ends_with?: Maybe<String>
   text_not_ends_with?: Maybe<String>
   AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>
   OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>
   NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>
}

export interface TagUpdateManyWithWhereNestedInput {
   where: TagScalarWhereInput
   data: TagUpdateManyDataInput
}

export interface TagUpdateManyDataInput {
   tag?: Maybe<Int>
   name?: Maybe<String>
   text?: Maybe<String>
}

export interface SourceUpdateOneWithoutItemsInput {
   create?: Maybe<SourceCreateWithoutItemsInput>
   update?: Maybe<SourceUpdateWithoutItemsDataInput>
   upsert?: Maybe<SourceUpsertWithoutItemsInput>
   delete?: Maybe<Boolean>
   disconnect?: Maybe<Boolean>
   connect?: Maybe<SourceWhereUniqueInput>
}

export interface SourceUpdateWithoutItemsDataInput {
   slug?: Maybe<String>
   url?: Maybe<String>
   type?: Maybe<SourceEnum>
   title?: Maybe<String>
   description?: Maybe<String>
   timer?: Maybe<String>
   cron?: Maybe<CronUpdateOneInput>
   cover?: Maybe<String>
}

export interface CronUpdateOneInput {
   create?: Maybe<CronCreateInput>
   update?: Maybe<CronUpdateDataInput>
   upsert?: Maybe<CronUpsertNestedInput>
   delete?: Maybe<Boolean>
   disconnect?: Maybe<Boolean>
   connect?: Maybe<CronWhereUniqueInput>
}

export interface CronUpdateDataInput {
   pid?: Maybe<Int>
   health?: Maybe<Boolean>
   status?: Maybe<CronEnum>
   lastMessage?: Maybe<String>
}

export interface CronUpsertNestedInput {
   update: CronUpdateDataInput
   create: CronCreateInput
}

export interface SourceUpsertWithoutItemsInput {
   update: SourceUpdateWithoutItemsDataInput
   create: SourceCreateWithoutItemsInput
}

export interface WaveUpdateOneInput {
   create?: Maybe<WaveCreateInput>
   update?: Maybe<WaveUpdateDataInput>
   upsert?: Maybe<WaveUpsertNestedInput>
   delete?: Maybe<Boolean>
   disconnect?: Maybe<Boolean>
   connect?: Maybe<WaveWhereUniqueInput>
}

export interface WaveUpdateDataInput {
   url?: Maybe<String>
   wave?: Maybe<WaveUpdatewaveInput>
}

export interface WaveUpdatewaveInput {
   set?: Maybe<Float[] | Float>
}

export interface WaveUpsertNestedInput {
   update: WaveUpdateDataInput
   create: WaveCreateInput
}

export interface ItemUpdateManyMutationInput {
   slug?: Maybe<String>
   guid?: Maybe<String>
   title?: Maybe<String>
   description?: Maybe<String>
   publishedAt?: Maybe<DateTimeInput>
   download?: Maybe<String>
   url?: Maybe<String>
   length?: Maybe<Int>
   type?: Maybe<String>
}

export interface SourceCreateInput {
   id?: Maybe<ID_Input>
   slug?: Maybe<String>
   url: String
   type?: Maybe<SourceEnum>
   title?: Maybe<String>
   description?: Maybe<String>
   items?: Maybe<ItemCreateManyWithoutSourceInput>
   timer?: Maybe<String>
   cron?: Maybe<CronCreateOneInput>
   cover?: Maybe<String>
}

export interface ItemCreateManyWithoutSourceInput {
   create?: Maybe<ItemCreateWithoutSourceInput[] | ItemCreateWithoutSourceInput>
   connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>
}

export interface ItemCreateWithoutSourceInput {
   id?: Maybe<ID_Input>
   slug: String
   guid: String
   tags?: Maybe<TagCreateManyInput>
   title?: Maybe<String>
   description?: Maybe<String>
   publishedAt?: Maybe<DateTimeInput>
   download?: Maybe<String>
   url?: Maybe<String>
   length?: Maybe<Int>
   type?: Maybe<String>
   waveform?: Maybe<WaveCreateOneInput>
}

export interface SourceUpdateInput {
   slug?: Maybe<String>
   url?: Maybe<String>
   type?: Maybe<SourceEnum>
   title?: Maybe<String>
   description?: Maybe<String>
   items?: Maybe<ItemUpdateManyWithoutSourceInput>
   timer?: Maybe<String>
   cron?: Maybe<CronUpdateOneInput>
   cover?: Maybe<String>
}

export interface ItemUpdateManyWithoutSourceInput {
   create?: Maybe<ItemCreateWithoutSourceInput[] | ItemCreateWithoutSourceInput>
   delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>
   connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>
   set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>
   disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>
   update?: Maybe<
      | ItemUpdateWithWhereUniqueWithoutSourceInput[]
      | ItemUpdateWithWhereUniqueWithoutSourceInput
   >
   upsert?: Maybe<
      | ItemUpsertWithWhereUniqueWithoutSourceInput[]
      | ItemUpsertWithWhereUniqueWithoutSourceInput
   >
   deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>
   updateMany?: Maybe<
      ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
   >
}

export interface ItemUpdateWithWhereUniqueWithoutSourceInput {
   where: ItemWhereUniqueInput
   data: ItemUpdateWithoutSourceDataInput
}

export interface ItemUpdateWithoutSourceDataInput {
   slug?: Maybe<String>
   guid?: Maybe<String>
   tags?: Maybe<TagUpdateManyInput>
   title?: Maybe<String>
   description?: Maybe<String>
   publishedAt?: Maybe<DateTimeInput>
   download?: Maybe<String>
   url?: Maybe<String>
   length?: Maybe<Int>
   type?: Maybe<String>
   waveform?: Maybe<WaveUpdateOneInput>
}

export interface ItemUpsertWithWhereUniqueWithoutSourceInput {
   where: ItemWhereUniqueInput
   update: ItemUpdateWithoutSourceDataInput
   create: ItemCreateWithoutSourceInput
}

export interface ItemScalarWhereInput {
   id?: Maybe<ID_Input>
   id_not?: Maybe<ID_Input>
   id_in?: Maybe<ID_Input[] | ID_Input>
   id_not_in?: Maybe<ID_Input[] | ID_Input>
   id_lt?: Maybe<ID_Input>
   id_lte?: Maybe<ID_Input>
   id_gt?: Maybe<ID_Input>
   id_gte?: Maybe<ID_Input>
   id_contains?: Maybe<ID_Input>
   id_not_contains?: Maybe<ID_Input>
   id_starts_with?: Maybe<ID_Input>
   id_not_starts_with?: Maybe<ID_Input>
   id_ends_with?: Maybe<ID_Input>
   id_not_ends_with?: Maybe<ID_Input>
   createdAt?: Maybe<DateTimeInput>
   createdAt_not?: Maybe<DateTimeInput>
   createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   createdAt_lt?: Maybe<DateTimeInput>
   createdAt_lte?: Maybe<DateTimeInput>
   createdAt_gt?: Maybe<DateTimeInput>
   createdAt_gte?: Maybe<DateTimeInput>
   updatedAt?: Maybe<DateTimeInput>
   updatedAt_not?: Maybe<DateTimeInput>
   updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   updatedAt_lt?: Maybe<DateTimeInput>
   updatedAt_lte?: Maybe<DateTimeInput>
   updatedAt_gt?: Maybe<DateTimeInput>
   updatedAt_gte?: Maybe<DateTimeInput>
   slug?: Maybe<String>
   slug_not?: Maybe<String>
   slug_in?: Maybe<String[] | String>
   slug_not_in?: Maybe<String[] | String>
   slug_lt?: Maybe<String>
   slug_lte?: Maybe<String>
   slug_gt?: Maybe<String>
   slug_gte?: Maybe<String>
   slug_contains?: Maybe<String>
   slug_not_contains?: Maybe<String>
   slug_starts_with?: Maybe<String>
   slug_not_starts_with?: Maybe<String>
   slug_ends_with?: Maybe<String>
   slug_not_ends_with?: Maybe<String>
   guid?: Maybe<String>
   guid_not?: Maybe<String>
   guid_in?: Maybe<String[] | String>
   guid_not_in?: Maybe<String[] | String>
   guid_lt?: Maybe<String>
   guid_lte?: Maybe<String>
   guid_gt?: Maybe<String>
   guid_gte?: Maybe<String>
   guid_contains?: Maybe<String>
   guid_not_contains?: Maybe<String>
   guid_starts_with?: Maybe<String>
   guid_not_starts_with?: Maybe<String>
   guid_ends_with?: Maybe<String>
   guid_not_ends_with?: Maybe<String>
   title?: Maybe<String>
   title_not?: Maybe<String>
   title_in?: Maybe<String[] | String>
   title_not_in?: Maybe<String[] | String>
   title_lt?: Maybe<String>
   title_lte?: Maybe<String>
   title_gt?: Maybe<String>
   title_gte?: Maybe<String>
   title_contains?: Maybe<String>
   title_not_contains?: Maybe<String>
   title_starts_with?: Maybe<String>
   title_not_starts_with?: Maybe<String>
   title_ends_with?: Maybe<String>
   title_not_ends_with?: Maybe<String>
   description?: Maybe<String>
   description_not?: Maybe<String>
   description_in?: Maybe<String[] | String>
   description_not_in?: Maybe<String[] | String>
   description_lt?: Maybe<String>
   description_lte?: Maybe<String>
   description_gt?: Maybe<String>
   description_gte?: Maybe<String>
   description_contains?: Maybe<String>
   description_not_contains?: Maybe<String>
   description_starts_with?: Maybe<String>
   description_not_starts_with?: Maybe<String>
   description_ends_with?: Maybe<String>
   description_not_ends_with?: Maybe<String>
   publishedAt?: Maybe<DateTimeInput>
   publishedAt_not?: Maybe<DateTimeInput>
   publishedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>
   publishedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>
   publishedAt_lt?: Maybe<DateTimeInput>
   publishedAt_lte?: Maybe<DateTimeInput>
   publishedAt_gt?: Maybe<DateTimeInput>
   publishedAt_gte?: Maybe<DateTimeInput>
   download?: Maybe<String>
   download_not?: Maybe<String>
   download_in?: Maybe<String[] | String>
   download_not_in?: Maybe<String[] | String>
   download_lt?: Maybe<String>
   download_lte?: Maybe<String>
   download_gt?: Maybe<String>
   download_gte?: Maybe<String>
   download_contains?: Maybe<String>
   download_not_contains?: Maybe<String>
   download_starts_with?: Maybe<String>
   download_not_starts_with?: Maybe<String>
   download_ends_with?: Maybe<String>
   download_not_ends_with?: Maybe<String>
   url?: Maybe<String>
   url_not?: Maybe<String>
   url_in?: Maybe<String[] | String>
   url_not_in?: Maybe<String[] | String>
   url_lt?: Maybe<String>
   url_lte?: Maybe<String>
   url_gt?: Maybe<String>
   url_gte?: Maybe<String>
   url_contains?: Maybe<String>
   url_not_contains?: Maybe<String>
   url_starts_with?: Maybe<String>
   url_not_starts_with?: Maybe<String>
   url_ends_with?: Maybe<String>
   url_not_ends_with?: Maybe<String>
   length?: Maybe<Int>
   length_not?: Maybe<Int>
   length_in?: Maybe<Int[] | Int>
   length_not_in?: Maybe<Int[] | Int>
   length_lt?: Maybe<Int>
   length_lte?: Maybe<Int>
   length_gt?: Maybe<Int>
   length_gte?: Maybe<Int>
   type?: Maybe<String>
   type_not?: Maybe<String>
   type_in?: Maybe<String[] | String>
   type_not_in?: Maybe<String[] | String>
   type_lt?: Maybe<String>
   type_lte?: Maybe<String>
   type_gt?: Maybe<String>
   type_gte?: Maybe<String>
   type_contains?: Maybe<String>
   type_not_contains?: Maybe<String>
   type_starts_with?: Maybe<String>
   type_not_starts_with?: Maybe<String>
   type_ends_with?: Maybe<String>
   type_not_ends_with?: Maybe<String>
   AND?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>
   OR?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>
   NOT?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>
}

export interface ItemUpdateManyWithWhereNestedInput {
   where: ItemScalarWhereInput
   data: ItemUpdateManyDataInput
}

export interface ItemUpdateManyDataInput {
   slug?: Maybe<String>
   guid?: Maybe<String>
   title?: Maybe<String>
   description?: Maybe<String>
   publishedAt?: Maybe<DateTimeInput>
   download?: Maybe<String>
   url?: Maybe<String>
   length?: Maybe<Int>
   type?: Maybe<String>
}

export interface SourceUpdateManyMutationInput {
   slug?: Maybe<String>
   url?: Maybe<String>
   type?: Maybe<SourceEnum>
   title?: Maybe<String>
   description?: Maybe<String>
   timer?: Maybe<String>
   cover?: Maybe<String>
}

export interface TagUpdateInput {
   tag?: Maybe<Int>
   name?: Maybe<String>
   text?: Maybe<String>
}

export interface TagUpdateManyMutationInput {
   tag?: Maybe<Int>
   name?: Maybe<String>
   text?: Maybe<String>
}

export interface UserCreateInput {
   id?: Maybe<ID_Input>
   name: String
   bio?: Maybe<String>
   userName: String
   email: String
   password: String
}

export interface UserUpdateInput {
   name?: Maybe<String>
   bio?: Maybe<String>
   userName?: Maybe<String>
   email?: Maybe<String>
   password?: Maybe<String>
}

export interface UserUpdateManyMutationInput {
   name?: Maybe<String>
   bio?: Maybe<String>
   userName?: Maybe<String>
   email?: Maybe<String>
   password?: Maybe<String>
}

export interface WaveUpdateInput {
   url?: Maybe<String>
   wave?: Maybe<WaveUpdatewaveInput>
}

export interface WaveUpdateManyMutationInput {
   url?: Maybe<String>
   wave?: Maybe<WaveUpdatewaveInput>
}

export interface ConfigSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<ConfigWhereInput>
   AND?: Maybe<ConfigSubscriptionWhereInput[] | ConfigSubscriptionWhereInput>
}

export interface CronSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<CronWhereInput>
   AND?: Maybe<CronSubscriptionWhereInput[] | CronSubscriptionWhereInput>
}

export interface ItemSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<ItemWhereInput>
   AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>
}

export interface SourceSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<SourceWhereInput>
   AND?: Maybe<SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput>
}

export interface TagSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<TagWhereInput>
   AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>
}

export interface UserSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<UserWhereInput>
   AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>
}

export interface WaveSubscriptionWhereInput {
   mutation_in?: Maybe<MutationType[] | MutationType>
   updatedFields_contains?: Maybe<String>
   updatedFields_contains_every?: Maybe<String[] | String>
   updatedFields_contains_some?: Maybe<String[] | String>
   node?: Maybe<WaveWhereInput>
   AND?: Maybe<WaveSubscriptionWhereInput[] | WaveSubscriptionWhereInput>
}

export interface NodeNode {
   id: ID_Output
}

export interface Config {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   timeZone: String
   liveUrl: String
   liveStatusUrl: String
   placeholderCover: String
}

export interface ConfigPromise extends Promise<Config>, Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   timeZone: () => Promise<String>
   liveUrl: () => Promise<String>
   liveStatusUrl: () => Promise<String>
   placeholderCover: () => Promise<String>
}

export interface ConfigSubscription
   extends Promise<AsyncIterator<Config>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   timeZone: () => Promise<AsyncIterator<String>>
   liveUrl: () => Promise<AsyncIterator<String>>
   liveStatusUrl: () => Promise<AsyncIterator<String>>
   placeholderCover: () => Promise<AsyncIterator<String>>
}

export interface ConfigNullablePromise
   extends Promise<Config | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   timeZone: () => Promise<String>
   liveUrl: () => Promise<String>
   liveStatusUrl: () => Promise<String>
   placeholderCover: () => Promise<String>
}

export interface ConfigConnection {
   pageInfo: PageInfo
   edges: ConfigEdge[]
}

export interface ConfigConnectionPromise
   extends Promise<ConfigConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<ConfigEdge>>() => T
   aggregate: <T = AggregateConfigPromise>() => T
}

export interface ConfigConnectionSubscription
   extends Promise<AsyncIterator<ConfigConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<ConfigEdgeSubscription>>>() => T
   aggregate: <T = AggregateConfigSubscription>() => T
}

export interface PageInfo {
   hasNextPage: Boolean
   hasPreviousPage: Boolean
   startCursor?: String
   endCursor?: String
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
   hasNextPage: () => Promise<Boolean>
   hasPreviousPage: () => Promise<Boolean>
   startCursor: () => Promise<String>
   endCursor: () => Promise<String>
}

export interface PageInfoSubscription
   extends Promise<AsyncIterator<PageInfo>>,
      Fragmentable {
   hasNextPage: () => Promise<AsyncIterator<Boolean>>
   hasPreviousPage: () => Promise<AsyncIterator<Boolean>>
   startCursor: () => Promise<AsyncIterator<String>>
   endCursor: () => Promise<AsyncIterator<String>>
}

export interface ConfigEdge {
   node: Config
   cursor: String
}

export interface ConfigEdgePromise extends Promise<ConfigEdge>, Fragmentable {
   node: <T = ConfigPromise>() => T
   cursor: () => Promise<String>
}

export interface ConfigEdgeSubscription
   extends Promise<AsyncIterator<ConfigEdge>>,
      Fragmentable {
   node: <T = ConfigSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateConfig {
   count: Int
}

export interface AggregateConfigPromise
   extends Promise<AggregateConfig>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateConfigSubscription
   extends Promise<AsyncIterator<AggregateConfig>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface Cron {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   pid: Int
   health?: Boolean
   status: CronEnum
   lastMessage?: String
}

export interface CronPromise extends Promise<Cron>, Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   pid: () => Promise<Int>
   health: () => Promise<Boolean>
   status: () => Promise<CronEnum>
   lastMessage: () => Promise<String>
}

export interface CronSubscription
   extends Promise<AsyncIterator<Cron>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   pid: () => Promise<AsyncIterator<Int>>
   health: () => Promise<AsyncIterator<Boolean>>
   status: () => Promise<AsyncIterator<CronEnum>>
   lastMessage: () => Promise<AsyncIterator<String>>
}

export interface CronNullablePromise
   extends Promise<Cron | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   pid: () => Promise<Int>
   health: () => Promise<Boolean>
   status: () => Promise<CronEnum>
   lastMessage: () => Promise<String>
}

export interface CronConnection {
   pageInfo: PageInfo
   edges: CronEdge[]
}

export interface CronConnectionPromise
   extends Promise<CronConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<CronEdge>>() => T
   aggregate: <T = AggregateCronPromise>() => T
}

export interface CronConnectionSubscription
   extends Promise<AsyncIterator<CronConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<CronEdgeSubscription>>>() => T
   aggregate: <T = AggregateCronSubscription>() => T
}

export interface CronEdge {
   node: Cron
   cursor: String
}

export interface CronEdgePromise extends Promise<CronEdge>, Fragmentable {
   node: <T = CronPromise>() => T
   cursor: () => Promise<String>
}

export interface CronEdgeSubscription
   extends Promise<AsyncIterator<CronEdge>>,
      Fragmentable {
   node: <T = CronSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateCron {
   count: Int
}

export interface AggregateCronPromise
   extends Promise<AggregateCron>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateCronSubscription
   extends Promise<AsyncIterator<AggregateCron>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface Item {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   slug: String
   guid: String
   title?: String
   description?: String
   publishedAt?: DateTimeOutput
   download?: String
   url?: String
   length?: Int
   type?: String
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   slug: () => Promise<String>
   guid: () => Promise<String>
   tags: <T = FragmentableArray<Tag>>(args?: {
      where?: TagWhereInput
      orderBy?: TagOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   title: () => Promise<String>
   description: () => Promise<String>
   publishedAt: () => Promise<DateTimeOutput>
   download: () => Promise<String>
   url: () => Promise<String>
   length: () => Promise<Int>
   type: () => Promise<String>
   source: <T = SourcePromise>() => T
   waveform: <T = WavePromise>() => T
}

export interface ItemSubscription
   extends Promise<AsyncIterator<Item>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   slug: () => Promise<AsyncIterator<String>>
   guid: () => Promise<AsyncIterator<String>>
   tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
      where?: TagWhereInput
      orderBy?: TagOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   title: () => Promise<AsyncIterator<String>>
   description: () => Promise<AsyncIterator<String>>
   publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   download: () => Promise<AsyncIterator<String>>
   url: () => Promise<AsyncIterator<String>>
   length: () => Promise<AsyncIterator<Int>>
   type: () => Promise<AsyncIterator<String>>
   source: <T = SourceSubscription>() => T
   waveform: <T = WaveSubscription>() => T
}

export interface ItemNullablePromise
   extends Promise<Item | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   slug: () => Promise<String>
   guid: () => Promise<String>
   tags: <T = FragmentableArray<Tag>>(args?: {
      where?: TagWhereInput
      orderBy?: TagOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   title: () => Promise<String>
   description: () => Promise<String>
   publishedAt: () => Promise<DateTimeOutput>
   download: () => Promise<String>
   url: () => Promise<String>
   length: () => Promise<Int>
   type: () => Promise<String>
   source: <T = SourcePromise>() => T
   waveform: <T = WavePromise>() => T
}

export interface Tag {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   tag: Int
   name: String
   text: String
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   tag: () => Promise<Int>
   name: () => Promise<String>
   text: () => Promise<String>
}

export interface TagSubscription
   extends Promise<AsyncIterator<Tag>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   tag: () => Promise<AsyncIterator<Int>>
   name: () => Promise<AsyncIterator<String>>
   text: () => Promise<AsyncIterator<String>>
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   tag: () => Promise<Int>
   name: () => Promise<String>
   text: () => Promise<String>
}

export interface Source {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   slug?: String
   url: String
   type: SourceEnum
   title?: String
   description?: String
   timer: String
   cover?: String
}

export interface SourcePromise extends Promise<Source>, Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   slug: () => Promise<String>
   url: () => Promise<String>
   type: () => Promise<SourceEnum>
   title: () => Promise<String>
   description: () => Promise<String>
   items: <T = FragmentableArray<Item>>(args?: {
      where?: ItemWhereInput
      orderBy?: ItemOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   timer: () => Promise<String>
   cron: <T = CronPromise>() => T
   cover: () => Promise<String>
}

export interface SourceSubscription
   extends Promise<AsyncIterator<Source>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   slug: () => Promise<AsyncIterator<String>>
   url: () => Promise<AsyncIterator<String>>
   type: () => Promise<AsyncIterator<SourceEnum>>
   title: () => Promise<AsyncIterator<String>>
   description: () => Promise<AsyncIterator<String>>
   items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
      where?: ItemWhereInput
      orderBy?: ItemOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   timer: () => Promise<AsyncIterator<String>>
   cron: <T = CronSubscription>() => T
   cover: () => Promise<AsyncIterator<String>>
}

export interface SourceNullablePromise
   extends Promise<Source | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   slug: () => Promise<String>
   url: () => Promise<String>
   type: () => Promise<SourceEnum>
   title: () => Promise<String>
   description: () => Promise<String>
   items: <T = FragmentableArray<Item>>(args?: {
      where?: ItemWhereInput
      orderBy?: ItemOrderByInput
      skip?: Int
      after?: String
      before?: String
      first?: Int
      last?: Int
   }) => T
   timer: () => Promise<String>
   cron: <T = CronPromise>() => T
   cover: () => Promise<String>
}

export interface Wave {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   url: String
   wave: Float[]
}

export interface WavePromise extends Promise<Wave>, Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   url: () => Promise<String>
   wave: () => Promise<Float[]>
}

export interface WaveSubscription
   extends Promise<AsyncIterator<Wave>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   url: () => Promise<AsyncIterator<String>>
   wave: () => Promise<AsyncIterator<Float[]>>
}

export interface WaveNullablePromise
   extends Promise<Wave | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   url: () => Promise<String>
   wave: () => Promise<Float[]>
}

export interface ItemConnection {
   pageInfo: PageInfo
   edges: ItemEdge[]
}

export interface ItemConnectionPromise
   extends Promise<ItemConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<ItemEdge>>() => T
   aggregate: <T = AggregateItemPromise>() => T
}

export interface ItemConnectionSubscription
   extends Promise<AsyncIterator<ItemConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T
   aggregate: <T = AggregateItemSubscription>() => T
}

export interface ItemEdge {
   node: Item
   cursor: String
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
   node: <T = ItemPromise>() => T
   cursor: () => Promise<String>
}

export interface ItemEdgeSubscription
   extends Promise<AsyncIterator<ItemEdge>>,
      Fragmentable {
   node: <T = ItemSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateItem {
   count: Int
}

export interface AggregateItemPromise
   extends Promise<AggregateItem>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateItemSubscription
   extends Promise<AsyncIterator<AggregateItem>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface SourceConnection {
   pageInfo: PageInfo
   edges: SourceEdge[]
}

export interface SourceConnectionPromise
   extends Promise<SourceConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<SourceEdge>>() => T
   aggregate: <T = AggregateSourcePromise>() => T
}

export interface SourceConnectionSubscription
   extends Promise<AsyncIterator<SourceConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<SourceEdgeSubscription>>>() => T
   aggregate: <T = AggregateSourceSubscription>() => T
}

export interface SourceEdge {
   node: Source
   cursor: String
}

export interface SourceEdgePromise extends Promise<SourceEdge>, Fragmentable {
   node: <T = SourcePromise>() => T
   cursor: () => Promise<String>
}

export interface SourceEdgeSubscription
   extends Promise<AsyncIterator<SourceEdge>>,
      Fragmentable {
   node: <T = SourceSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateSource {
   count: Int
}

export interface AggregateSourcePromise
   extends Promise<AggregateSource>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateSourceSubscription
   extends Promise<AsyncIterator<AggregateSource>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface TagConnection {
   pageInfo: PageInfo
   edges: TagEdge[]
}

export interface TagConnectionPromise
   extends Promise<TagConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<TagEdge>>() => T
   aggregate: <T = AggregateTagPromise>() => T
}

export interface TagConnectionSubscription
   extends Promise<AsyncIterator<TagConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T
   aggregate: <T = AggregateTagSubscription>() => T
}

export interface TagEdge {
   node: Tag
   cursor: String
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
   node: <T = TagPromise>() => T
   cursor: () => Promise<String>
}

export interface TagEdgeSubscription
   extends Promise<AsyncIterator<TagEdge>>,
      Fragmentable {
   node: <T = TagSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateTag {
   count: Int
}

export interface AggregateTagPromise
   extends Promise<AggregateTag>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateTagSubscription
   extends Promise<AsyncIterator<AggregateTag>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface User {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   name: String
   bio?: String
   userName: String
   email: String
   password: String
}

export interface UserPromise extends Promise<User>, Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   name: () => Promise<String>
   bio: () => Promise<String>
   userName: () => Promise<String>
   email: () => Promise<String>
   password: () => Promise<String>
}

export interface UserSubscription
   extends Promise<AsyncIterator<User>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   name: () => Promise<AsyncIterator<String>>
   bio: () => Promise<AsyncIterator<String>>
   userName: () => Promise<AsyncIterator<String>>
   email: () => Promise<AsyncIterator<String>>
   password: () => Promise<AsyncIterator<String>>
}

export interface UserNullablePromise
   extends Promise<User | null>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   name: () => Promise<String>
   bio: () => Promise<String>
   userName: () => Promise<String>
   email: () => Promise<String>
   password: () => Promise<String>
}

export interface UserConnection {
   pageInfo: PageInfo
   edges: UserEdge[]
}

export interface UserConnectionPromise
   extends Promise<UserConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<UserEdge>>() => T
   aggregate: <T = AggregateUserPromise>() => T
}

export interface UserConnectionSubscription
   extends Promise<AsyncIterator<UserConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T
   aggregate: <T = AggregateUserSubscription>() => T
}

export interface UserEdge {
   node: User
   cursor: String
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
   node: <T = UserPromise>() => T
   cursor: () => Promise<String>
}

export interface UserEdgeSubscription
   extends Promise<AsyncIterator<UserEdge>>,
      Fragmentable {
   node: <T = UserSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateUser {
   count: Int
}

export interface AggregateUserPromise
   extends Promise<AggregateUser>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateUserSubscription
   extends Promise<AsyncIterator<AggregateUser>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface WaveConnection {
   pageInfo: PageInfo
   edges: WaveEdge[]
}

export interface WaveConnectionPromise
   extends Promise<WaveConnection>,
      Fragmentable {
   pageInfo: <T = PageInfoPromise>() => T
   edges: <T = FragmentableArray<WaveEdge>>() => T
   aggregate: <T = AggregateWavePromise>() => T
}

export interface WaveConnectionSubscription
   extends Promise<AsyncIterator<WaveConnection>>,
      Fragmentable {
   pageInfo: <T = PageInfoSubscription>() => T
   edges: <T = Promise<AsyncIterator<WaveEdgeSubscription>>>() => T
   aggregate: <T = AggregateWaveSubscription>() => T
}

export interface WaveEdge {
   node: Wave
   cursor: String
}

export interface WaveEdgePromise extends Promise<WaveEdge>, Fragmentable {
   node: <T = WavePromise>() => T
   cursor: () => Promise<String>
}

export interface WaveEdgeSubscription
   extends Promise<AsyncIterator<WaveEdge>>,
      Fragmentable {
   node: <T = WaveSubscription>() => T
   cursor: () => Promise<AsyncIterator<String>>
}

export interface AggregateWave {
   count: Int
}

export interface AggregateWavePromise
   extends Promise<AggregateWave>,
      Fragmentable {
   count: () => Promise<Int>
}

export interface AggregateWaveSubscription
   extends Promise<AsyncIterator<AggregateWave>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Int>>
}

export interface BatchPayload {
   count: Long
}

export interface BatchPayloadPromise
   extends Promise<BatchPayload>,
      Fragmentable {
   count: () => Promise<Long>
}

export interface BatchPayloadSubscription
   extends Promise<AsyncIterator<BatchPayload>>,
      Fragmentable {
   count: () => Promise<AsyncIterator<Long>>
}

export interface ConfigSubscriptionPayload {
   mutation: MutationType
   node: Config
   updatedFields: String[]
   previousValues: ConfigPreviousValues
}

export interface ConfigSubscriptionPayloadPromise
   extends Promise<ConfigSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = ConfigPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = ConfigPreviousValuesPromise>() => T
}

export interface ConfigSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<ConfigSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = ConfigSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = ConfigPreviousValuesSubscription>() => T
}

export interface ConfigPreviousValues {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   timeZone: String
   liveUrl: String
   liveStatusUrl: String
   placeholderCover: String
}

export interface ConfigPreviousValuesPromise
   extends Promise<ConfigPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   timeZone: () => Promise<String>
   liveUrl: () => Promise<String>
   liveStatusUrl: () => Promise<String>
   placeholderCover: () => Promise<String>
}

export interface ConfigPreviousValuesSubscription
   extends Promise<AsyncIterator<ConfigPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   timeZone: () => Promise<AsyncIterator<String>>
   liveUrl: () => Promise<AsyncIterator<String>>
   liveStatusUrl: () => Promise<AsyncIterator<String>>
   placeholderCover: () => Promise<AsyncIterator<String>>
}

export interface CronSubscriptionPayload {
   mutation: MutationType
   node: Cron
   updatedFields: String[]
   previousValues: CronPreviousValues
}

export interface CronSubscriptionPayloadPromise
   extends Promise<CronSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = CronPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = CronPreviousValuesPromise>() => T
}

export interface CronSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<CronSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = CronSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = CronPreviousValuesSubscription>() => T
}

export interface CronPreviousValues {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   pid: Int
   health?: Boolean
   status: CronEnum
   lastMessage?: String
}

export interface CronPreviousValuesPromise
   extends Promise<CronPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   pid: () => Promise<Int>
   health: () => Promise<Boolean>
   status: () => Promise<CronEnum>
   lastMessage: () => Promise<String>
}

export interface CronPreviousValuesSubscription
   extends Promise<AsyncIterator<CronPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   pid: () => Promise<AsyncIterator<Int>>
   health: () => Promise<AsyncIterator<Boolean>>
   status: () => Promise<AsyncIterator<CronEnum>>
   lastMessage: () => Promise<AsyncIterator<String>>
}

export interface ItemSubscriptionPayload {
   mutation: MutationType
   node: Item
   updatedFields: String[]
   previousValues: ItemPreviousValues
}

export interface ItemSubscriptionPayloadPromise
   extends Promise<ItemSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = ItemPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = ItemPreviousValuesPromise>() => T
}

export interface ItemSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = ItemSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = ItemPreviousValuesSubscription>() => T
}

export interface ItemPreviousValues {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   slug: String
   guid: String
   title?: String
   description?: String
   publishedAt?: DateTimeOutput
   download?: String
   url?: String
   length?: Int
   type?: String
}

export interface ItemPreviousValuesPromise
   extends Promise<ItemPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   slug: () => Promise<String>
   guid: () => Promise<String>
   title: () => Promise<String>
   description: () => Promise<String>
   publishedAt: () => Promise<DateTimeOutput>
   download: () => Promise<String>
   url: () => Promise<String>
   length: () => Promise<Int>
   type: () => Promise<String>
}

export interface ItemPreviousValuesSubscription
   extends Promise<AsyncIterator<ItemPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   slug: () => Promise<AsyncIterator<String>>
   guid: () => Promise<AsyncIterator<String>>
   title: () => Promise<AsyncIterator<String>>
   description: () => Promise<AsyncIterator<String>>
   publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   download: () => Promise<AsyncIterator<String>>
   url: () => Promise<AsyncIterator<String>>
   length: () => Promise<AsyncIterator<Int>>
   type: () => Promise<AsyncIterator<String>>
}

export interface SourceSubscriptionPayload {
   mutation: MutationType
   node: Source
   updatedFields: String[]
   previousValues: SourcePreviousValues
}

export interface SourceSubscriptionPayloadPromise
   extends Promise<SourceSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = SourcePromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = SourcePreviousValuesPromise>() => T
}

export interface SourceSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<SourceSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = SourceSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = SourcePreviousValuesSubscription>() => T
}

export interface SourcePreviousValues {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   slug?: String
   url: String
   type: SourceEnum
   title?: String
   description?: String
   timer: String
   cover?: String
}

export interface SourcePreviousValuesPromise
   extends Promise<SourcePreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   slug: () => Promise<String>
   url: () => Promise<String>
   type: () => Promise<SourceEnum>
   title: () => Promise<String>
   description: () => Promise<String>
   timer: () => Promise<String>
   cover: () => Promise<String>
}

export interface SourcePreviousValuesSubscription
   extends Promise<AsyncIterator<SourcePreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   slug: () => Promise<AsyncIterator<String>>
   url: () => Promise<AsyncIterator<String>>
   type: () => Promise<AsyncIterator<SourceEnum>>
   title: () => Promise<AsyncIterator<String>>
   description: () => Promise<AsyncIterator<String>>
   timer: () => Promise<AsyncIterator<String>>
   cover: () => Promise<AsyncIterator<String>>
}

export interface TagSubscriptionPayload {
   mutation: MutationType
   node: Tag
   updatedFields: String[]
   previousValues: TagPreviousValues
}

export interface TagSubscriptionPayloadPromise
   extends Promise<TagSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = TagPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = TagPreviousValuesPromise>() => T
}

export interface TagSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<TagSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = TagSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = TagPreviousValuesSubscription>() => T
}

export interface TagPreviousValues {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   tag: Int
   name: String
   text: String
}

export interface TagPreviousValuesPromise
   extends Promise<TagPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   tag: () => Promise<Int>
   name: () => Promise<String>
   text: () => Promise<String>
}

export interface TagPreviousValuesSubscription
   extends Promise<AsyncIterator<TagPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   tag: () => Promise<AsyncIterator<Int>>
   name: () => Promise<AsyncIterator<String>>
   text: () => Promise<AsyncIterator<String>>
}

export interface UserSubscriptionPayload {
   mutation: MutationType
   node: User
   updatedFields: String[]
   previousValues: UserPreviousValues
}

export interface UserSubscriptionPayloadPromise
   extends Promise<UserSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = UserPromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = UserPreviousValuesPromise>() => T
}

export interface UserSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<UserSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = UserSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = UserPreviousValuesSubscription>() => T
}

export interface UserPreviousValues {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   name: String
   bio?: String
   userName: String
   email: String
   password: String
}

export interface UserPreviousValuesPromise
   extends Promise<UserPreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   name: () => Promise<String>
   bio: () => Promise<String>
   userName: () => Promise<String>
   email: () => Promise<String>
   password: () => Promise<String>
}

export interface UserPreviousValuesSubscription
   extends Promise<AsyncIterator<UserPreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   name: () => Promise<AsyncIterator<String>>
   bio: () => Promise<AsyncIterator<String>>
   userName: () => Promise<AsyncIterator<String>>
   email: () => Promise<AsyncIterator<String>>
   password: () => Promise<AsyncIterator<String>>
}

export interface WaveSubscriptionPayload {
   mutation: MutationType
   node: Wave
   updatedFields: String[]
   previousValues: WavePreviousValues
}

export interface WaveSubscriptionPayloadPromise
   extends Promise<WaveSubscriptionPayload>,
      Fragmentable {
   mutation: () => Promise<MutationType>
   node: <T = WavePromise>() => T
   updatedFields: () => Promise<String[]>
   previousValues: <T = WavePreviousValuesPromise>() => T
}

export interface WaveSubscriptionPayloadSubscription
   extends Promise<AsyncIterator<WaveSubscriptionPayload>>,
      Fragmentable {
   mutation: () => Promise<AsyncIterator<MutationType>>
   node: <T = WaveSubscription>() => T
   updatedFields: () => Promise<AsyncIterator<String[]>>
   previousValues: <T = WavePreviousValuesSubscription>() => T
}

export interface WavePreviousValues {
   id: ID_Output
   createdAt: DateTimeOutput
   updatedAt: DateTimeOutput
   url: String
   wave: Float[]
}

export interface WavePreviousValuesPromise
   extends Promise<WavePreviousValues>,
      Fragmentable {
   id: () => Promise<ID_Output>
   createdAt: () => Promise<DateTimeOutput>
   updatedAt: () => Promise<DateTimeOutput>
   url: () => Promise<String>
   wave: () => Promise<Float[]>
}

export interface WavePreviousValuesSubscription
   extends Promise<AsyncIterator<WavePreviousValues>>,
      Fragmentable {
   id: () => Promise<AsyncIterator<ID_Output>>
   createdAt: () => Promise<AsyncIterator<DateTimeOutput>>
   updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>
   url: () => Promise<AsyncIterator<String>>
   wave: () => Promise<AsyncIterator<Float[]>>
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number
export type ID_Output = string

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number

export type Long = string

/**
 * Model Metadata
 */

export const models: Model[] = [
   {
      name: 'User',
      embedded: false
   },
   {
      name: 'Config',
      embedded: false
   },
   {
      name: 'SourceEnum',
      embedded: false
   },
   {
      name: 'Source',
      embedded: false
   },
   {
      name: 'Tag',
      embedded: false
   },
   {
      name: 'Item',
      embedded: false
   },
   {
      name: 'Wave',
      embedded: false
   },
   {
      name: 'CronEnum',
      embedded: false
   },
   {
      name: 'Cron',
      embedded: false
   }
]

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
   typeDefs,
   models,
   endpoint: `${process.env['PRISMA_URL']}`
})
export const prisma = new Prisma()
