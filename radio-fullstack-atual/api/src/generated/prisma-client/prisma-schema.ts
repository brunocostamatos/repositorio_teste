// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `
   type AggregateConfig {
      count: Int!
   }

   type AggregateCron {
      count: Int!
   }

   type AggregateItem {
      count: Int!
   }

   type AggregateSource {
      count: Int!
   }

   type AggregateTag {
      count: Int!
   }

   type AggregateUser {
      count: Int!
   }

   type AggregateWave {
      count: Int!
   }

   type BatchPayload {
      count: Long!
   }

   type Config {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      timeZone: String!
      liveUrl: String!
      liveStatusUrl: String!
      placeholderCover: String!
   }

   type ConfigConnection {
      pageInfo: PageInfo!
      edges: [ConfigEdge]!
      aggregate: AggregateConfig!
   }

   input ConfigCreateInput {
      id: ID
      timeZone: String!
      liveUrl: String!
      liveStatusUrl: String!
      placeholderCover: String!
   }

   type ConfigEdge {
      node: Config!
      cursor: String!
   }

   enum ConfigOrderByInput {
      id_ASC
      id_DESC
      createdAt_ASC
      createdAt_DESC
      updatedAt_ASC
      updatedAt_DESC
      timeZone_ASC
      timeZone_DESC
      liveUrl_ASC
      liveUrl_DESC
      liveStatusUrl_ASC
      liveStatusUrl_DESC
      placeholderCover_ASC
      placeholderCover_DESC
   }

   type ConfigPreviousValues {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      timeZone: String!
      liveUrl: String!
      liveStatusUrl: String!
      placeholderCover: String!
   }

   type ConfigSubscriptionPayload {
      mutation: MutationType!
      node: Config
      updatedFields: [String!]
      previousValues: ConfigPreviousValues
   }

   input ConfigSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: ConfigWhereInput
      AND: [ConfigSubscriptionWhereInput!]
   }

   input ConfigUpdateInput {
      timeZone: String
      liveUrl: String
      liveStatusUrl: String
      placeholderCover: String
   }

   input ConfigUpdateManyMutationInput {
      timeZone: String
      liveUrl: String
      liveStatusUrl: String
      placeholderCover: String
   }

   input ConfigWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      createdAt: DateTime
      createdAt_not: DateTime
      createdAt_in: [DateTime!]
      createdAt_not_in: [DateTime!]
      createdAt_lt: DateTime
      createdAt_lte: DateTime
      createdAt_gt: DateTime
      createdAt_gte: DateTime
      updatedAt: DateTime
      updatedAt_not: DateTime
      updatedAt_in: [DateTime!]
      updatedAt_not_in: [DateTime!]
      updatedAt_lt: DateTime
      updatedAt_lte: DateTime
      updatedAt_gt: DateTime
      updatedAt_gte: DateTime
      timeZone: String
      timeZone_not: String
      timeZone_in: [String!]
      timeZone_not_in: [String!]
      timeZone_lt: String
      timeZone_lte: String
      timeZone_gt: String
      timeZone_gte: String
      timeZone_contains: String
      timeZone_not_contains: String
      timeZone_starts_with: String
      timeZone_not_starts_with: String
      timeZone_ends_with: String
      timeZone_not_ends_with: String
      liveUrl: String
      liveUrl_not: String
      liveUrl_in: [String!]
      liveUrl_not_in: [String!]
      liveUrl_lt: String
      liveUrl_lte: String
      liveUrl_gt: String
      liveUrl_gte: String
      liveUrl_contains: String
      liveUrl_not_contains: String
      liveUrl_starts_with: String
      liveUrl_not_starts_with: String
      liveUrl_ends_with: String
      liveUrl_not_ends_with: String
      liveStatusUrl: String
      liveStatusUrl_not: String
      liveStatusUrl_in: [String!]
      liveStatusUrl_not_in: [String!]
      liveStatusUrl_lt: String
      liveStatusUrl_lte: String
      liveStatusUrl_gt: String
      liveStatusUrl_gte: String
      liveStatusUrl_contains: String
      liveStatusUrl_not_contains: String
      liveStatusUrl_starts_with: String
      liveStatusUrl_not_starts_with: String
      liveStatusUrl_ends_with: String
      liveStatusUrl_not_ends_with: String
      placeholderCover: String
      placeholderCover_not: String
      placeholderCover_in: [String!]
      placeholderCover_not_in: [String!]
      placeholderCover_lt: String
      placeholderCover_lte: String
      placeholderCover_gt: String
      placeholderCover_gte: String
      placeholderCover_contains: String
      placeholderCover_not_contains: String
      placeholderCover_starts_with: String
      placeholderCover_not_starts_with: String
      placeholderCover_ends_with: String
      placeholderCover_not_ends_with: String
      AND: [ConfigWhereInput!]
   }

   input ConfigWhereUniqueInput {
      id: ID
   }

   type Cron {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      pid: Int!
      health: Boolean
      status: CronEnum!
      lastMessage: String
   }

   type CronConnection {
      pageInfo: PageInfo!
      edges: [CronEdge]!
      aggregate: AggregateCron!
   }

   input CronCreateInput {
      id: ID
      pid: Int!
      health: Boolean
      status: CronEnum!
      lastMessage: String
   }

   input CronCreateOneInput {
      create: CronCreateInput
      connect: CronWhereUniqueInput
   }

   type CronEdge {
      node: Cron!
      cursor: String!
   }

   enum CronEnum {
      STARTING
      RUNNING
      IDLE
      STOPED
   }

   enum CronOrderByInput {
      id_ASC
      id_DESC
      createdAt_ASC
      createdAt_DESC
      updatedAt_ASC
      updatedAt_DESC
      pid_ASC
      pid_DESC
      health_ASC
      health_DESC
      status_ASC
      status_DESC
      lastMessage_ASC
      lastMessage_DESC
   }

   type CronPreviousValues {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      pid: Int!
      health: Boolean
      status: CronEnum!
      lastMessage: String
   }

   type CronSubscriptionPayload {
      mutation: MutationType!
      node: Cron
      updatedFields: [String!]
      previousValues: CronPreviousValues
   }

   input CronSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: CronWhereInput
      AND: [CronSubscriptionWhereInput!]
   }

   input CronUpdateDataInput {
      pid: Int
      health: Boolean
      status: CronEnum
      lastMessage: String
   }

   input CronUpdateInput {
      pid: Int
      health: Boolean
      status: CronEnum
      lastMessage: String
   }

   input CronUpdateManyMutationInput {
      pid: Int
      health: Boolean
      status: CronEnum
      lastMessage: String
   }

   input CronUpdateOneInput {
      create: CronCreateInput
      update: CronUpdateDataInput
      upsert: CronUpsertNestedInput
      delete: Boolean
      disconnect: Boolean
      connect: CronWhereUniqueInput
   }

   input CronUpsertNestedInput {
      update: CronUpdateDataInput!
      create: CronCreateInput!
   }

   input CronWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      createdAt: DateTime
      createdAt_not: DateTime
      createdAt_in: [DateTime!]
      createdAt_not_in: [DateTime!]
      createdAt_lt: DateTime
      createdAt_lte: DateTime
      createdAt_gt: DateTime
      createdAt_gte: DateTime
      updatedAt: DateTime
      updatedAt_not: DateTime
      updatedAt_in: [DateTime!]
      updatedAt_not_in: [DateTime!]
      updatedAt_lt: DateTime
      updatedAt_lte: DateTime
      updatedAt_gt: DateTime
      updatedAt_gte: DateTime
      pid: Int
      pid_not: Int
      pid_in: [Int!]
      pid_not_in: [Int!]
      pid_lt: Int
      pid_lte: Int
      pid_gt: Int
      pid_gte: Int
      health: Boolean
      health_not: Boolean
      status: CronEnum
      status_not: CronEnum
      status_in: [CronEnum!]
      status_not_in: [CronEnum!]
      lastMessage: String
      lastMessage_not: String
      lastMessage_in: [String!]
      lastMessage_not_in: [String!]
      lastMessage_lt: String
      lastMessage_lte: String
      lastMessage_gt: String
      lastMessage_gte: String
      lastMessage_contains: String
      lastMessage_not_contains: String
      lastMessage_starts_with: String
      lastMessage_not_starts_with: String
      lastMessage_ends_with: String
      lastMessage_not_ends_with: String
      AND: [CronWhereInput!]
   }

   input CronWhereUniqueInput {
      id: ID
      pid: Int
   }

   scalar DateTime

   type Item {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      slug: String!
      guid: String!
      tags(
         where: TagWhereInput
         orderBy: TagOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Tag!]
      title: String
      description: String
      publishedAt: DateTime
      download: String
      url: String
      length: Int
      type: String
      source: Source
      waveform: Wave
   }

   type ItemConnection {
      pageInfo: PageInfo!
      edges: [ItemEdge]!
      aggregate: AggregateItem!
   }

   input ItemCreateInput {
      id: ID
      slug: String!
      guid: String!
      tags: TagCreateManyInput
      title: String
      description: String
      publishedAt: DateTime
      download: String
      url: String
      length: Int
      type: String
      source: SourceCreateOneWithoutItemsInput
      waveform: WaveCreateOneInput
   }

   input ItemCreateManyWithoutSourceInput {
      create: [ItemCreateWithoutSourceInput!]
      connect: [ItemWhereUniqueInput!]
   }

   input ItemCreateWithoutSourceInput {
      id: ID
      slug: String!
      guid: String!
      tags: TagCreateManyInput
      title: String
      description: String
      publishedAt: DateTime
      download: String
      url: String
      length: Int
      type: String
      waveform: WaveCreateOneInput
   }

   type ItemEdge {
      node: Item!
      cursor: String!
   }

   enum ItemOrderByInput {
      id_ASC
      id_DESC
      createdAt_ASC
      createdAt_DESC
      updatedAt_ASC
      updatedAt_DESC
      slug_ASC
      slug_DESC
      guid_ASC
      guid_DESC
      title_ASC
      title_DESC
      description_ASC
      description_DESC
      publishedAt_ASC
      publishedAt_DESC
      download_ASC
      download_DESC
      url_ASC
      url_DESC
      length_ASC
      length_DESC
      type_ASC
      type_DESC
   }

   type ItemPreviousValues {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      slug: String!
      guid: String!
      title: String
      description: String
      publishedAt: DateTime
      download: String
      url: String
      length: Int
      type: String
   }

   input ItemScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      createdAt: DateTime
      createdAt_not: DateTime
      createdAt_in: [DateTime!]
      createdAt_not_in: [DateTime!]
      createdAt_lt: DateTime
      createdAt_lte: DateTime
      createdAt_gt: DateTime
      createdAt_gte: DateTime
      updatedAt: DateTime
      updatedAt_not: DateTime
      updatedAt_in: [DateTime!]
      updatedAt_not_in: [DateTime!]
      updatedAt_lt: DateTime
      updatedAt_lte: DateTime
      updatedAt_gt: DateTime
      updatedAt_gte: DateTime
      slug: String
      slug_not: String
      slug_in: [String!]
      slug_not_in: [String!]
      slug_lt: String
      slug_lte: String
      slug_gt: String
      slug_gte: String
      slug_contains: String
      slug_not_contains: String
      slug_starts_with: String
      slug_not_starts_with: String
      slug_ends_with: String
      slug_not_ends_with: String
      guid: String
      guid_not: String
      guid_in: [String!]
      guid_not_in: [String!]
      guid_lt: String
      guid_lte: String
      guid_gt: String
      guid_gte: String
      guid_contains: String
      guid_not_contains: String
      guid_starts_with: String
      guid_not_starts_with: String
      guid_ends_with: String
      guid_not_ends_with: String
      title: String
      title_not: String
      title_in: [String!]
      title_not_in: [String!]
      title_lt: String
      title_lte: String
      title_gt: String
      title_gte: String
      title_contains: String
      title_not_contains: String
      title_starts_with: String
      title_not_starts_with: String
      title_ends_with: String
      title_not_ends_with: String
      description: String
      description_not: String
      description_in: [String!]
      description_not_in: [String!]
      description_lt: String
      description_lte: String
      description_gt: String
      description_gte: String
      description_contains: String
      description_not_contains: String
      description_starts_with: String
      description_not_starts_with: String
      description_ends_with: String
      description_not_ends_with: String
      publishedAt: DateTime
      publishedAt_not: DateTime
      publishedAt_in: [DateTime!]
      publishedAt_not_in: [DateTime!]
      publishedAt_lt: DateTime
      publishedAt_lte: DateTime
      publishedAt_gt: DateTime
      publishedAt_gte: DateTime
      download: String
      download_not: String
      download_in: [String!]
      download_not_in: [String!]
      download_lt: String
      download_lte: String
      download_gt: String
      download_gte: String
      download_contains: String
      download_not_contains: String
      download_starts_with: String
      download_not_starts_with: String
      download_ends_with: String
      download_not_ends_with: String
      url: String
      url_not: String
      url_in: [String!]
      url_not_in: [String!]
      url_lt: String
      url_lte: String
      url_gt: String
      url_gte: String
      url_contains: String
      url_not_contains: String
      url_starts_with: String
      url_not_starts_with: String
      url_ends_with: String
      url_not_ends_with: String
      length: Int
      length_not: Int
      length_in: [Int!]
      length_not_in: [Int!]
      length_lt: Int
      length_lte: Int
      length_gt: Int
      length_gte: Int
      type: String
      type_not: String
      type_in: [String!]
      type_not_in: [String!]
      type_lt: String
      type_lte: String
      type_gt: String
      type_gte: String
      type_contains: String
      type_not_contains: String
      type_starts_with: String
      type_not_starts_with: String
      type_ends_with: String
      type_not_ends_with: String
      AND: [ItemScalarWhereInput!]
      OR: [ItemScalarWhereInput!]
      NOT: [ItemScalarWhereInput!]
   }

   type ItemSubscriptionPayload {
      mutation: MutationType!
      node: Item
      updatedFields: [String!]
      previousValues: ItemPreviousValues
   }

   input ItemSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: ItemWhereInput
      AND: [ItemSubscriptionWhereInput!]
   }

   input ItemUpdateInput {
      slug: String
      guid: String
      tags: TagUpdateManyInput
      title: String
      description: String
      publishedAt: DateTime
      download: String
      url: String
      length: Int
      type: String
      source: SourceUpdateOneWithoutItemsInput
      waveform: WaveUpdateOneInput
   }

   input ItemUpdateManyDataInput {
      slug: String
      guid: String
      title: String
      description: String
      publishedAt: DateTime
      download: String
      url: String
      length: Int
      type: String
   }

   input ItemUpdateManyMutationInput {
      slug: String
      guid: String
      title: String
      description: String
      publishedAt: DateTime
      download: String
      url: String
      length: Int
      type: String
   }

   input ItemUpdateManyWithoutSourceInput {
      create: [ItemCreateWithoutSourceInput!]
      delete: [ItemWhereUniqueInput!]
      connect: [ItemWhereUniqueInput!]
      set: [ItemWhereUniqueInput!]
      disconnect: [ItemWhereUniqueInput!]
      update: [ItemUpdateWithWhereUniqueWithoutSourceInput!]
      upsert: [ItemUpsertWithWhereUniqueWithoutSourceInput!]
      deleteMany: [ItemScalarWhereInput!]
      updateMany: [ItemUpdateManyWithWhereNestedInput!]
   }

   input ItemUpdateManyWithWhereNestedInput {
      where: ItemScalarWhereInput!
      data: ItemUpdateManyDataInput!
   }

   input ItemUpdateWithoutSourceDataInput {
      slug: String
      guid: String
      tags: TagUpdateManyInput
      title: String
      description: String
      publishedAt: DateTime
      download: String
      url: String
      length: Int
      type: String
      waveform: WaveUpdateOneInput
   }

   input ItemUpdateWithWhereUniqueWithoutSourceInput {
      where: ItemWhereUniqueInput!
      data: ItemUpdateWithoutSourceDataInput!
   }

   input ItemUpsertWithWhereUniqueWithoutSourceInput {
      where: ItemWhereUniqueInput!
      update: ItemUpdateWithoutSourceDataInput!
      create: ItemCreateWithoutSourceInput!
   }

   input ItemWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      createdAt: DateTime
      createdAt_not: DateTime
      createdAt_in: [DateTime!]
      createdAt_not_in: [DateTime!]
      createdAt_lt: DateTime
      createdAt_lte: DateTime
      createdAt_gt: DateTime
      createdAt_gte: DateTime
      updatedAt: DateTime
      updatedAt_not: DateTime
      updatedAt_in: [DateTime!]
      updatedAt_not_in: [DateTime!]
      updatedAt_lt: DateTime
      updatedAt_lte: DateTime
      updatedAt_gt: DateTime
      updatedAt_gte: DateTime
      slug: String
      slug_not: String
      slug_in: [String!]
      slug_not_in: [String!]
      slug_lt: String
      slug_lte: String
      slug_gt: String
      slug_gte: String
      slug_contains: String
      slug_not_contains: String
      slug_starts_with: String
      slug_not_starts_with: String
      slug_ends_with: String
      slug_not_ends_with: String
      guid: String
      guid_not: String
      guid_in: [String!]
      guid_not_in: [String!]
      guid_lt: String
      guid_lte: String
      guid_gt: String
      guid_gte: String
      guid_contains: String
      guid_not_contains: String
      guid_starts_with: String
      guid_not_starts_with: String
      guid_ends_with: String
      guid_not_ends_with: String
      tags_some: TagWhereInput
      title: String
      title_not: String
      title_in: [String!]
      title_not_in: [String!]
      title_lt: String
      title_lte: String
      title_gt: String
      title_gte: String
      title_contains: String
      title_not_contains: String
      title_starts_with: String
      title_not_starts_with: String
      title_ends_with: String
      title_not_ends_with: String
      description: String
      description_not: String
      description_in: [String!]
      description_not_in: [String!]
      description_lt: String
      description_lte: String
      description_gt: String
      description_gte: String
      description_contains: String
      description_not_contains: String
      description_starts_with: String
      description_not_starts_with: String
      description_ends_with: String
      description_not_ends_with: String
      publishedAt: DateTime
      publishedAt_not: DateTime
      publishedAt_in: [DateTime!]
      publishedAt_not_in: [DateTime!]
      publishedAt_lt: DateTime
      publishedAt_lte: DateTime
      publishedAt_gt: DateTime
      publishedAt_gte: DateTime
      download: String
      download_not: String
      download_in: [String!]
      download_not_in: [String!]
      download_lt: String
      download_lte: String
      download_gt: String
      download_gte: String
      download_contains: String
      download_not_contains: String
      download_starts_with: String
      download_not_starts_with: String
      download_ends_with: String
      download_not_ends_with: String
      url: String
      url_not: String
      url_in: [String!]
      url_not_in: [String!]
      url_lt: String
      url_lte: String
      url_gt: String
      url_gte: String
      url_contains: String
      url_not_contains: String
      url_starts_with: String
      url_not_starts_with: String
      url_ends_with: String
      url_not_ends_with: String
      length: Int
      length_not: Int
      length_in: [Int!]
      length_not_in: [Int!]
      length_lt: Int
      length_lte: Int
      length_gt: Int
      length_gte: Int
      type: String
      type_not: String
      type_in: [String!]
      type_not_in: [String!]
      type_lt: String
      type_lte: String
      type_gt: String
      type_gte: String
      type_contains: String
      type_not_contains: String
      type_starts_with: String
      type_not_starts_with: String
      type_ends_with: String
      type_not_ends_with: String
      source: SourceWhereInput
      waveform: WaveWhereInput
      AND: [ItemWhereInput!]
   }

   input ItemWhereUniqueInput {
      id: ID
      slug: String
      guid: String
   }

   scalar Long

   type Mutation {
      createConfig(data: ConfigCreateInput!): Config!
      updateConfig(
         data: ConfigUpdateInput!
         where: ConfigWhereUniqueInput!
      ): Config
      updateManyConfigs(
         data: ConfigUpdateManyMutationInput!
         where: ConfigWhereInput
      ): BatchPayload!
      upsertConfig(
         where: ConfigWhereUniqueInput!
         create: ConfigCreateInput!
         update: ConfigUpdateInput!
      ): Config!
      deleteConfig(where: ConfigWhereUniqueInput!): Config
      deleteManyConfigs(where: ConfigWhereInput): BatchPayload!
      createCron(data: CronCreateInput!): Cron!
      updateCron(data: CronUpdateInput!, where: CronWhereUniqueInput!): Cron
      updateManyCrons(
         data: CronUpdateManyMutationInput!
         where: CronWhereInput
      ): BatchPayload!
      upsertCron(
         where: CronWhereUniqueInput!
         create: CronCreateInput!
         update: CronUpdateInput!
      ): Cron!
      deleteCron(where: CronWhereUniqueInput!): Cron
      deleteManyCrons(where: CronWhereInput): BatchPayload!
      createItem(data: ItemCreateInput!): Item!
      updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
      updateManyItems(
         data: ItemUpdateManyMutationInput!
         where: ItemWhereInput
      ): BatchPayload!
      upsertItem(
         where: ItemWhereUniqueInput!
         create: ItemCreateInput!
         update: ItemUpdateInput!
      ): Item!
      deleteItem(where: ItemWhereUniqueInput!): Item
      deleteManyItems(where: ItemWhereInput): BatchPayload!
      createSource(data: SourceCreateInput!): Source!
      updateSource(
         data: SourceUpdateInput!
         where: SourceWhereUniqueInput!
      ): Source
      updateManySources(
         data: SourceUpdateManyMutationInput!
         where: SourceWhereInput
      ): BatchPayload!
      upsertSource(
         where: SourceWhereUniqueInput!
         create: SourceCreateInput!
         update: SourceUpdateInput!
      ): Source!
      deleteSource(where: SourceWhereUniqueInput!): Source
      deleteManySources(where: SourceWhereInput): BatchPayload!
      createTag(data: TagCreateInput!): Tag!
      updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
      updateManyTags(
         data: TagUpdateManyMutationInput!
         where: TagWhereInput
      ): BatchPayload!
      upsertTag(
         where: TagWhereUniqueInput!
         create: TagCreateInput!
         update: TagUpdateInput!
      ): Tag!
      deleteTag(where: TagWhereUniqueInput!): Tag
      deleteManyTags(where: TagWhereInput): BatchPayload!
      createUser(data: UserCreateInput!): User!
      updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
      updateManyUsers(
         data: UserUpdateManyMutationInput!
         where: UserWhereInput
      ): BatchPayload!
      upsertUser(
         where: UserWhereUniqueInput!
         create: UserCreateInput!
         update: UserUpdateInput!
      ): User!
      deleteUser(where: UserWhereUniqueInput!): User
      deleteManyUsers(where: UserWhereInput): BatchPayload!
      createWave(data: WaveCreateInput!): Wave!
      updateWave(data: WaveUpdateInput!, where: WaveWhereUniqueInput!): Wave
      updateManyWaves(
         data: WaveUpdateManyMutationInput!
         where: WaveWhereInput
      ): BatchPayload!
      upsertWave(
         where: WaveWhereUniqueInput!
         create: WaveCreateInput!
         update: WaveUpdateInput!
      ): Wave!
      deleteWave(where: WaveWhereUniqueInput!): Wave
      deleteManyWaves(where: WaveWhereInput): BatchPayload!
   }

   enum MutationType {
      CREATED
      UPDATED
      DELETED
   }

   interface Node {
      id: ID!
   }

   type PageInfo {
      hasNextPage: Boolean!
      hasPreviousPage: Boolean!
      startCursor: String
      endCursor: String
   }

   type Query {
      config(where: ConfigWhereUniqueInput!): Config
      configs(
         where: ConfigWhereInput
         orderBy: ConfigOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Config]!
      configsConnection(
         where: ConfigWhereInput
         orderBy: ConfigOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): ConfigConnection!
      cron(where: CronWhereUniqueInput!): Cron
      crons(
         where: CronWhereInput
         orderBy: CronOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Cron]!
      cronsConnection(
         where: CronWhereInput
         orderBy: CronOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): CronConnection!
      item(where: ItemWhereUniqueInput!): Item
      items(
         where: ItemWhereInput
         orderBy: ItemOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Item]!
      itemsConnection(
         where: ItemWhereInput
         orderBy: ItemOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): ItemConnection!
      source(where: SourceWhereUniqueInput!): Source
      sources(
         where: SourceWhereInput
         orderBy: SourceOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Source]!
      sourcesConnection(
         where: SourceWhereInput
         orderBy: SourceOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): SourceConnection!
      tag(where: TagWhereUniqueInput!): Tag
      tags(
         where: TagWhereInput
         orderBy: TagOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Tag]!
      tagsConnection(
         where: TagWhereInput
         orderBy: TagOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): TagConnection!
      user(where: UserWhereUniqueInput!): User
      users(
         where: UserWhereInput
         orderBy: UserOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [User]!
      usersConnection(
         where: UserWhereInput
         orderBy: UserOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): UserConnection!
      wave(where: WaveWhereUniqueInput!): Wave
      waves(
         where: WaveWhereInput
         orderBy: WaveOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Wave]!
      wavesConnection(
         where: WaveWhereInput
         orderBy: WaveOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): WaveConnection!
      node(id: ID!): Node
   }

   type Source {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      slug: String
      url: String!
      type: SourceEnum!
      title: String
      description: String
      items(
         where: ItemWhereInput
         orderBy: ItemOrderByInput
         skip: Int
         after: String
         before: String
         first: Int
         last: Int
      ): [Item!]
      timer: String!
      cron: Cron
      cover: String
   }

   type SourceConnection {
      pageInfo: PageInfo!
      edges: [SourceEdge]!
      aggregate: AggregateSource!
   }

   input SourceCreateInput {
      id: ID
      slug: String
      url: String!
      type: SourceEnum
      title: String
      description: String
      items: ItemCreateManyWithoutSourceInput
      timer: String
      cron: CronCreateOneInput
      cover: String
   }

   input SourceCreateOneWithoutItemsInput {
      create: SourceCreateWithoutItemsInput
      connect: SourceWhereUniqueInput
   }

   input SourceCreateWithoutItemsInput {
      id: ID
      slug: String
      url: String!
      type: SourceEnum
      title: String
      description: String
      timer: String
      cron: CronCreateOneInput
      cover: String
   }

   type SourceEdge {
      node: Source!
      cursor: String!
   }

   enum SourceEnum {
      PODCAST
      NEWS
      PAGE
   }

   enum SourceOrderByInput {
      id_ASC
      id_DESC
      createdAt_ASC
      createdAt_DESC
      updatedAt_ASC
      updatedAt_DESC
      slug_ASC
      slug_DESC
      url_ASC
      url_DESC
      type_ASC
      type_DESC
      title_ASC
      title_DESC
      description_ASC
      description_DESC
      timer_ASC
      timer_DESC
      cover_ASC
      cover_DESC
   }

   type SourcePreviousValues {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      slug: String
      url: String!
      type: SourceEnum!
      title: String
      description: String
      timer: String!
      cover: String
   }

   type SourceSubscriptionPayload {
      mutation: MutationType!
      node: Source
      updatedFields: [String!]
      previousValues: SourcePreviousValues
   }

   input SourceSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: SourceWhereInput
      AND: [SourceSubscriptionWhereInput!]
   }

   input SourceUpdateInput {
      slug: String
      url: String
      type: SourceEnum
      title: String
      description: String
      items: ItemUpdateManyWithoutSourceInput
      timer: String
      cron: CronUpdateOneInput
      cover: String
   }

   input SourceUpdateManyMutationInput {
      slug: String
      url: String
      type: SourceEnum
      title: String
      description: String
      timer: String
      cover: String
   }

   input SourceUpdateOneWithoutItemsInput {
      create: SourceCreateWithoutItemsInput
      update: SourceUpdateWithoutItemsDataInput
      upsert: SourceUpsertWithoutItemsInput
      delete: Boolean
      disconnect: Boolean
      connect: SourceWhereUniqueInput
   }

   input SourceUpdateWithoutItemsDataInput {
      slug: String
      url: String
      type: SourceEnum
      title: String
      description: String
      timer: String
      cron: CronUpdateOneInput
      cover: String
   }

   input SourceUpsertWithoutItemsInput {
      update: SourceUpdateWithoutItemsDataInput!
      create: SourceCreateWithoutItemsInput!
   }

   input SourceWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      createdAt: DateTime
      createdAt_not: DateTime
      createdAt_in: [DateTime!]
      createdAt_not_in: [DateTime!]
      createdAt_lt: DateTime
      createdAt_lte: DateTime
      createdAt_gt: DateTime
      createdAt_gte: DateTime
      updatedAt: DateTime
      updatedAt_not: DateTime
      updatedAt_in: [DateTime!]
      updatedAt_not_in: [DateTime!]
      updatedAt_lt: DateTime
      updatedAt_lte: DateTime
      updatedAt_gt: DateTime
      updatedAt_gte: DateTime
      slug: String
      slug_not: String
      slug_in: [String!]
      slug_not_in: [String!]
      slug_lt: String
      slug_lte: String
      slug_gt: String
      slug_gte: String
      slug_contains: String
      slug_not_contains: String
      slug_starts_with: String
      slug_not_starts_with: String
      slug_ends_with: String
      slug_not_ends_with: String
      url: String
      url_not: String
      url_in: [String!]
      url_not_in: [String!]
      url_lt: String
      url_lte: String
      url_gt: String
      url_gte: String
      url_contains: String
      url_not_contains: String
      url_starts_with: String
      url_not_starts_with: String
      url_ends_with: String
      url_not_ends_with: String
      type: SourceEnum
      type_not: SourceEnum
      type_in: [SourceEnum!]
      type_not_in: [SourceEnum!]
      title: String
      title_not: String
      title_in: [String!]
      title_not_in: [String!]
      title_lt: String
      title_lte: String
      title_gt: String
      title_gte: String
      title_contains: String
      title_not_contains: String
      title_starts_with: String
      title_not_starts_with: String
      title_ends_with: String
      title_not_ends_with: String
      description: String
      description_not: String
      description_in: [String!]
      description_not_in: [String!]
      description_lt: String
      description_lte: String
      description_gt: String
      description_gte: String
      description_contains: String
      description_not_contains: String
      description_starts_with: String
      description_not_starts_with: String
      description_ends_with: String
      description_not_ends_with: String
      items_some: ItemWhereInput
      timer: String
      timer_not: String
      timer_in: [String!]
      timer_not_in: [String!]
      timer_lt: String
      timer_lte: String
      timer_gt: String
      timer_gte: String
      timer_contains: String
      timer_not_contains: String
      timer_starts_with: String
      timer_not_starts_with: String
      timer_ends_with: String
      timer_not_ends_with: String
      cron: CronWhereInput
      cover: String
      cover_not: String
      cover_in: [String!]
      cover_not_in: [String!]
      cover_lt: String
      cover_lte: String
      cover_gt: String
      cover_gte: String
      cover_contains: String
      cover_not_contains: String
      cover_starts_with: String
      cover_not_starts_with: String
      cover_ends_with: String
      cover_not_ends_with: String
      AND: [SourceWhereInput!]
   }

   input SourceWhereUniqueInput {
      id: ID
      slug: String
      url: String
   }

   type Subscription {
      config(where: ConfigSubscriptionWhereInput): ConfigSubscriptionPayload
      cron(where: CronSubscriptionWhereInput): CronSubscriptionPayload
      item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
      source(where: SourceSubscriptionWhereInput): SourceSubscriptionPayload
      tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
      user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
      wave(where: WaveSubscriptionWhereInput): WaveSubscriptionPayload
   }

   type Tag {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      tag: Int!
      name: String!
      text: String!
   }

   type TagConnection {
      pageInfo: PageInfo!
      edges: [TagEdge]!
      aggregate: AggregateTag!
   }

   input TagCreateInput {
      id: ID
      tag: Int!
      name: String!
      text: String!
   }

   input TagCreateManyInput {
      create: [TagCreateInput!]
      connect: [TagWhereUniqueInput!]
   }

   type TagEdge {
      node: Tag!
      cursor: String!
   }

   enum TagOrderByInput {
      id_ASC
      id_DESC
      createdAt_ASC
      createdAt_DESC
      updatedAt_ASC
      updatedAt_DESC
      tag_ASC
      tag_DESC
      name_ASC
      name_DESC
      text_ASC
      text_DESC
   }

   type TagPreviousValues {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      tag: Int!
      name: String!
      text: String!
   }

   input TagScalarWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      createdAt: DateTime
      createdAt_not: DateTime
      createdAt_in: [DateTime!]
      createdAt_not_in: [DateTime!]
      createdAt_lt: DateTime
      createdAt_lte: DateTime
      createdAt_gt: DateTime
      createdAt_gte: DateTime
      updatedAt: DateTime
      updatedAt_not: DateTime
      updatedAt_in: [DateTime!]
      updatedAt_not_in: [DateTime!]
      updatedAt_lt: DateTime
      updatedAt_lte: DateTime
      updatedAt_gt: DateTime
      updatedAt_gte: DateTime
      tag: Int
      tag_not: Int
      tag_in: [Int!]
      tag_not_in: [Int!]
      tag_lt: Int
      tag_lte: Int
      tag_gt: Int
      tag_gte: Int
      name: String
      name_not: String
      name_in: [String!]
      name_not_in: [String!]
      name_lt: String
      name_lte: String
      name_gt: String
      name_gte: String
      name_contains: String
      name_not_contains: String
      name_starts_with: String
      name_not_starts_with: String
      name_ends_with: String
      name_not_ends_with: String
      text: String
      text_not: String
      text_in: [String!]
      text_not_in: [String!]
      text_lt: String
      text_lte: String
      text_gt: String
      text_gte: String
      text_contains: String
      text_not_contains: String
      text_starts_with: String
      text_not_starts_with: String
      text_ends_with: String
      text_not_ends_with: String
      AND: [TagScalarWhereInput!]
      OR: [TagScalarWhereInput!]
      NOT: [TagScalarWhereInput!]
   }

   type TagSubscriptionPayload {
      mutation: MutationType!
      node: Tag
      updatedFields: [String!]
      previousValues: TagPreviousValues
   }

   input TagSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: TagWhereInput
      AND: [TagSubscriptionWhereInput!]
   }

   input TagUpdateDataInput {
      tag: Int
      name: String
      text: String
   }

   input TagUpdateInput {
      tag: Int
      name: String
      text: String
   }

   input TagUpdateManyDataInput {
      tag: Int
      name: String
      text: String
   }

   input TagUpdateManyInput {
      create: [TagCreateInput!]
      update: [TagUpdateWithWhereUniqueNestedInput!]
      upsert: [TagUpsertWithWhereUniqueNestedInput!]
      delete: [TagWhereUniqueInput!]
      connect: [TagWhereUniqueInput!]
      set: [TagWhereUniqueInput!]
      disconnect: [TagWhereUniqueInput!]
      deleteMany: [TagScalarWhereInput!]
      updateMany: [TagUpdateManyWithWhereNestedInput!]
   }

   input TagUpdateManyMutationInput {
      tag: Int
      name: String
      text: String
   }

   input TagUpdateManyWithWhereNestedInput {
      where: TagScalarWhereInput!
      data: TagUpdateManyDataInput!
   }

   input TagUpdateWithWhereUniqueNestedInput {
      where: TagWhereUniqueInput!
      data: TagUpdateDataInput!
   }

   input TagUpsertWithWhereUniqueNestedInput {
      where: TagWhereUniqueInput!
      update: TagUpdateDataInput!
      create: TagCreateInput!
   }

   input TagWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      createdAt: DateTime
      createdAt_not: DateTime
      createdAt_in: [DateTime!]
      createdAt_not_in: [DateTime!]
      createdAt_lt: DateTime
      createdAt_lte: DateTime
      createdAt_gt: DateTime
      createdAt_gte: DateTime
      updatedAt: DateTime
      updatedAt_not: DateTime
      updatedAt_in: [DateTime!]
      updatedAt_not_in: [DateTime!]
      updatedAt_lt: DateTime
      updatedAt_lte: DateTime
      updatedAt_gt: DateTime
      updatedAt_gte: DateTime
      tag: Int
      tag_not: Int
      tag_in: [Int!]
      tag_not_in: [Int!]
      tag_lt: Int
      tag_lte: Int
      tag_gt: Int
      tag_gte: Int
      name: String
      name_not: String
      name_in: [String!]
      name_not_in: [String!]
      name_lt: String
      name_lte: String
      name_gt: String
      name_gte: String
      name_contains: String
      name_not_contains: String
      name_starts_with: String
      name_not_starts_with: String
      name_ends_with: String
      name_not_ends_with: String
      text: String
      text_not: String
      text_in: [String!]
      text_not_in: [String!]
      text_lt: String
      text_lte: String
      text_gt: String
      text_gte: String
      text_contains: String
      text_not_contains: String
      text_starts_with: String
      text_not_starts_with: String
      text_ends_with: String
      text_not_ends_with: String
      AND: [TagWhereInput!]
   }

   input TagWhereUniqueInput {
      id: ID
      tag: Int
   }

   type User {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      name: String!
      bio: String
      userName: String!
      email: String!
      password: String!
   }

   type UserConnection {
      pageInfo: PageInfo!
      edges: [UserEdge]!
      aggregate: AggregateUser!
   }

   input UserCreateInput {
      id: ID
      name: String!
      bio: String
      userName: String!
      email: String!
      password: String!
   }

   type UserEdge {
      node: User!
      cursor: String!
   }

   enum UserOrderByInput {
      id_ASC
      id_DESC
      createdAt_ASC
      createdAt_DESC
      updatedAt_ASC
      updatedAt_DESC
      name_ASC
      name_DESC
      bio_ASC
      bio_DESC
      userName_ASC
      userName_DESC
      email_ASC
      email_DESC
      password_ASC
      password_DESC
   }

   type UserPreviousValues {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      name: String!
      bio: String
      userName: String!
      email: String!
      password: String!
   }

   type UserSubscriptionPayload {
      mutation: MutationType!
      node: User
      updatedFields: [String!]
      previousValues: UserPreviousValues
   }

   input UserSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: UserWhereInput
      AND: [UserSubscriptionWhereInput!]
   }

   input UserUpdateInput {
      name: String
      bio: String
      userName: String
      email: String
      password: String
   }

   input UserUpdateManyMutationInput {
      name: String
      bio: String
      userName: String
      email: String
      password: String
   }

   input UserWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      createdAt: DateTime
      createdAt_not: DateTime
      createdAt_in: [DateTime!]
      createdAt_not_in: [DateTime!]
      createdAt_lt: DateTime
      createdAt_lte: DateTime
      createdAt_gt: DateTime
      createdAt_gte: DateTime
      updatedAt: DateTime
      updatedAt_not: DateTime
      updatedAt_in: [DateTime!]
      updatedAt_not_in: [DateTime!]
      updatedAt_lt: DateTime
      updatedAt_lte: DateTime
      updatedAt_gt: DateTime
      updatedAt_gte: DateTime
      name: String
      name_not: String
      name_in: [String!]
      name_not_in: [String!]
      name_lt: String
      name_lte: String
      name_gt: String
      name_gte: String
      name_contains: String
      name_not_contains: String
      name_starts_with: String
      name_not_starts_with: String
      name_ends_with: String
      name_not_ends_with: String
      bio: String
      bio_not: String
      bio_in: [String!]
      bio_not_in: [String!]
      bio_lt: String
      bio_lte: String
      bio_gt: String
      bio_gte: String
      bio_contains: String
      bio_not_contains: String
      bio_starts_with: String
      bio_not_starts_with: String
      bio_ends_with: String
      bio_not_ends_with: String
      userName: String
      userName_not: String
      userName_in: [String!]
      userName_not_in: [String!]
      userName_lt: String
      userName_lte: String
      userName_gt: String
      userName_gte: String
      userName_contains: String
      userName_not_contains: String
      userName_starts_with: String
      userName_not_starts_with: String
      userName_ends_with: String
      userName_not_ends_with: String
      email: String
      email_not: String
      email_in: [String!]
      email_not_in: [String!]
      email_lt: String
      email_lte: String
      email_gt: String
      email_gte: String
      email_contains: String
      email_not_contains: String
      email_starts_with: String
      email_not_starts_with: String
      email_ends_with: String
      email_not_ends_with: String
      password: String
      password_not: String
      password_in: [String!]
      password_not_in: [String!]
      password_lt: String
      password_lte: String
      password_gt: String
      password_gte: String
      password_contains: String
      password_not_contains: String
      password_starts_with: String
      password_not_starts_with: String
      password_ends_with: String
      password_not_ends_with: String
      AND: [UserWhereInput!]
   }

   input UserWhereUniqueInput {
      id: ID
      userName: String
      email: String
   }

   type Wave {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      url: String!
      wave: [Float!]!
   }

   type WaveConnection {
      pageInfo: PageInfo!
      edges: [WaveEdge]!
      aggregate: AggregateWave!
   }

   input WaveCreateInput {
      id: ID
      url: String!
      wave: WaveCreatewaveInput
   }

   input WaveCreateOneInput {
      create: WaveCreateInput
      connect: WaveWhereUniqueInput
   }

   input WaveCreatewaveInput {
      set: [Float!]
   }

   type WaveEdge {
      node: Wave!
      cursor: String!
   }

   enum WaveOrderByInput {
      id_ASC
      id_DESC
      createdAt_ASC
      createdAt_DESC
      updatedAt_ASC
      updatedAt_DESC
      url_ASC
      url_DESC
   }

   type WavePreviousValues {
      id: ID!
      createdAt: DateTime!
      updatedAt: DateTime!
      url: String!
      wave: [Float!]!
   }

   type WaveSubscriptionPayload {
      mutation: MutationType!
      node: Wave
      updatedFields: [String!]
      previousValues: WavePreviousValues
   }

   input WaveSubscriptionWhereInput {
      mutation_in: [MutationType!]
      updatedFields_contains: String
      updatedFields_contains_every: [String!]
      updatedFields_contains_some: [String!]
      node: WaveWhereInput
      AND: [WaveSubscriptionWhereInput!]
   }

   input WaveUpdateDataInput {
      url: String
      wave: WaveUpdatewaveInput
   }

   input WaveUpdateInput {
      url: String
      wave: WaveUpdatewaveInput
   }

   input WaveUpdateManyMutationInput {
      url: String
      wave: WaveUpdatewaveInput
   }

   input WaveUpdateOneInput {
      create: WaveCreateInput
      update: WaveUpdateDataInput
      upsert: WaveUpsertNestedInput
      delete: Boolean
      disconnect: Boolean
      connect: WaveWhereUniqueInput
   }

   input WaveUpdatewaveInput {
      set: [Float!]
   }

   input WaveUpsertNestedInput {
      update: WaveUpdateDataInput!
      create: WaveCreateInput!
   }

   input WaveWhereInput {
      id: ID
      id_not: ID
      id_in: [ID!]
      id_not_in: [ID!]
      id_lt: ID
      id_lte: ID
      id_gt: ID
      id_gte: ID
      id_contains: ID
      id_not_contains: ID
      id_starts_with: ID
      id_not_starts_with: ID
      id_ends_with: ID
      id_not_ends_with: ID
      createdAt: DateTime
      createdAt_not: DateTime
      createdAt_in: [DateTime!]
      createdAt_not_in: [DateTime!]
      createdAt_lt: DateTime
      createdAt_lte: DateTime
      createdAt_gt: DateTime
      createdAt_gte: DateTime
      updatedAt: DateTime
      updatedAt_not: DateTime
      updatedAt_in: [DateTime!]
      updatedAt_not_in: [DateTime!]
      updatedAt_lt: DateTime
      updatedAt_lte: DateTime
      updatedAt_gt: DateTime
      updatedAt_gte: DateTime
      url: String
      url_not: String
      url_in: [String!]
      url_not_in: [String!]
      url_lt: String
      url_lte: String
      url_gt: String
      url_gte: String
      url_contains: String
      url_not_contains: String
      url_starts_with: String
      url_not_starts_with: String
      url_ends_with: String
      url_not_ends_with: String
      AND: [WaveWhereInput!]
   }

   input WaveWhereUniqueInput {
      id: ID
      url: String
   }
`
